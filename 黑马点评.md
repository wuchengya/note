# 黑马点评

## 基于session实现短信登陆功能

```java
public Result sendCode(String phone, HttpSession session) {
        //1检验手机号是否正确
        if(!RegexPatterns.PHONE_REGEX.matches(phone)){
            return Result.fail("手机号不匹配");
        }
        //2生成验证码
        String code = RandomUtil.randomNumbers(6);
        //3将验证码放入session中
        session.setAttribute("code",code);
        //4发送验证码
        log.info("验证码是：{}",code);

        return Result.ok();
    }
```

以上是核心逻辑，最主要的就是HttpSession。

1. **首次访问**：当你的浏览器第一次访问网站时，服务器（比如 Tomcat）会创建一个全新的 HttpSession 对象
2. **创建 Session ID**：同时，服务器会生成一个全局唯一的字符串，称为 Session ID
3. **发送 Session ID 给浏览器**：服务器会将这个 Session ID 通过一个叫 Cookie 的东西发送给你的浏览器。这个 Cookie 通常名字叫 JSESSIONID。
4. **浏览器保存 Cookie**：你的浏览器会自动保存这个 JSESSIONID Cookie。
5. **后续访问**：从第二次请求开始，你的浏览器每次访问这个网站时，都会**自动带上**这个 JSESSIONID Cookie。
6. **服务器识别用户**：服务器收到请求后，会读取 Cookie 里的 JSESSIONID，然后根据这个 ID 去内存里找到之前为你创建的那个 HttpSession 对象（用手环钥匙找到你的储物柜）。这样，服务器就“认出”你了！





### **Web 会话技术核心笔记：Cookie, HttpSession & JWT**

#### 核心问题：解决 HTTP 的“健忘症”

HTTP 协议是无状态的，服务器无法区分多次请求是否来自同一个用户。以下三种技术都是为了让服务器能“记住”你。

------



### **1. Cookie (超市积分卡)**

- **是什么？**
  - 服务器存放在**浏览器（客户端）**上的一小块数据（键值对）。
  - 浏览器在后续访问**同一个网站**时，会自动带上这张“卡片”。
- **核心特点：**
  - **存储在客户端**：保存在你的电脑上，所以不安全，不能存敏感信息。
  - **服务器驱动**：由服务器通过 Set-Cookie 指令创建。
  - **有有效期**：可以设置为“关闭浏览器就失效”（会话Cookie），或“在硬盘上存一段时间”（持久Cookie）。
  - **大小受限**：通常不能超过 4KB。
- **一句话总结：** **一张由服务器发行、由浏览器保管和出示的“身份证”或“积分卡”，用于客户端的状态记录。**

------



### **2. HttpSession (游乐园储物柜)**

- **是什么？**
  - 服务器为每个用户在**服务器内存中**创建的一个专属“储物柜”，用来存放该用户的会话数据。
- **工作原理：**
  1. 用户首次访问，服务器创建一个 HttpSession 对象（储物柜）。
  2. 服务器生成一个唯一的 Session ID (储物柜钥匙)。
  3. 服务器通过 **Cookie** 将这个 Session ID 发给浏览器保管。
  4. 浏览器后续访问时，带上存有 Session ID 的 Cookie。
  5. 服务器根据 Session ID 找到对应的储物柜，从而识别用户。
- **核心特点：**
  - **存储在服务器端**：数据安全，可以存敏感信息。
  - **有状态 (Stateful)**：服务器需要为每个用户维护一份数据，消耗内存。
  - **依赖 Cookie**：通常需要 Cookie 来传递 Session ID。
  - **扩展性差**：在多台服务器（集群）环境下需要做额外配置（Session共享），否则会出问题。
- **一句话总结：** **一个在服务器端的“专属储物柜”，通过存放在浏览器Cookie里的“钥匙”（Session ID）来识别主人。**

------



### **3. JWT (贵宾全场通行证)**

- **是什么？**
  - 一个经过加密**签名**的、包含了用户信息的**字符串**。它本身就是一张内容详尽、无法伪造的“通行证”。
- **结构 (三段式)：**
  1. Header (头部)：描述元信息，如签名算法。
  2. Payload (载荷)：存放用户信息（如用户ID、角色），**内容是公开的，不能存密码！**
  3. Signature (签名)：将前两部分加上一个**服务器私钥 (Secret)** 进行加密计算，用于**防伪**。
- **核心特点：**
  - **无状态 (Stateless)**：服务器不需要保存任何会话信息，只负责签发和验证。
  - **信息自包含**：所有必要信息都在 Token 内部，服务器拿到后即可解析使用。
  - **扩展性极好**：天然适用于分布式、微服务架构。
  - **不依赖 Cookie**：可以通过 HTTP 请求头 Authorization 传输，对 App、小程序等各种客户端友好。
- **一句话总结：** **一张由服务器签发、由客户端保管的“防伪通行证”，服务器无需记忆，见证认人。**

### **终极对比**

| 特性         | Cookie                | HttpSession           | JWT                         |
| ------------ | --------------------- | --------------------- | --------------------------- |
| **比喻**     | 积分卡                | 储物柜 + 钥匙         | 贵宾通行证                  |
| **数据位置** | **客户端**            | **服务器端**          | **客户端**                  |
| **状态**     | 客户端状态            | **有状态 (Stateful)** | **无状态 (Stateless)**      |
| **安全性**   | 低 (明文)             | 高                    | 中 (签名防篡改, 载荷公开)   |
| **扩展性**   | -                     | 差                    | **好**                      |
| **适用场景** | 记录偏好、辅助Session | 传统单体Web应用       | **前后端分离、微服务、API** |

创建 Session ID以及发送 Session ID 给浏览器和服务器识别用户需要我们手动写代码吗？

答案是：**完全不需要！这些底层的、繁琐的工作，已经由你使用的技术栈（Web服务器/Servlet容器）为你全自动处理好了。**

你作为开发者，被完美地保护在一个高层次的抽象之后，只需要关心业务逻辑。

让我们揭开这层“魔法”的面纱，看看幕后英雄是谁，以及它是如何工作的。

### 幕后英雄：Web 服务器 / Servlet 容器 (例如 Tomcat)

当你运行一个 Spring Boot 项目时，它内置了一个 Web 服务器，最常见的就是 **Tomcat**。Tomcat 是一个 **Servlet 容器**，它负责处理底层的 HTTP 请求和响应，并管理像 HttpSession 这样的 Web 组件。

**Tomcat 就是那个为你处理所有 Session 细节的“全自动管家”。**

下面是这个“管家”为你自动完成的详细工作流程：

#### 1. 创建 Session ID (全自动)

- **触发时机**：当你的代码第一次尝试获取当前用户的 Session 时。在你的例子中，就是 Spring Boot 准备将 HttpSession session 这个参数注入到你的 Controller 方法时。

- **Tomcat 的动作**：

  1. Tomcat 检查收到的 HTTP 请求中，有没有一个有效的 JSESSIONID Cookie。
  2. 对于一个新用户，请求中**没有**这个 Cookie。
  3. Tomcat 判定这是一个新会话，于是：
     - 在服务器内存中创建一个全新的 HttpSession 对象。
     - 调用内部的算法，生成一个**全局唯一的、足够随机、难以猜测的**字符串作为 Session ID。

  **你完全不需要关心这个 ID 是如何生成的。**

#### 2. 发送 Session ID 给浏览器 (全自动)

- **触发时机**：在处理完你的业务逻辑，准备将 HTTP 响应发送回浏览器之前。

- **Tomcat 的动作**：

  1. Tomcat 会“拦截”即将发出的响应。

  2. 它会自动在 **HTTP 响应头 (Response Header)** 中添加一行 Set-Cookie 指令。这行指令的内容大致如下：

     codeCode

     ```
     Set-Cookie: JSESSIONID=A1B2C3D4E5F6G7H8I9J0K1L2; Path=/; HttpOnly
     ```

  3. 然后，它才把完整的响应（包括你的业务数据和这个 Set-Cookie 头）发送给浏览器。

  **你只需要 return Result.ok();，Tomcat 会自动帮你完成添加 Cookie 的所有工作。**

#### 3. 服务器识别用户 (全自动)

- **触发时机**：当同一个用户发起第二次、第三次...请求时。

- **浏览器和 Tomcat 的配合**：

  1. **浏览器**：在收到上一步的 Set-Cookie 指令后，它会把 JSESSIONID=A1B2C3... 这个 Cookie 保存起来。根据 HTTP 规范，在后续访问同一个网站时，浏览器会**自动地**在 **HTTP 请求头 (Request Header)** 中附带上这个 Cookie：

     codeCode

     ```
     Cookie: JSESSIONID=A1B2C3D4E5F6G7H8I9J0K1L2
     ```

  2. **Tomcat**：当它收到这个新的请求时，它会：

     - 解析请求头，找到 Cookie 字段。
     - 提取出 JSESSIONID 的值 (A1B2C3...)。
     - 拿着这个 ID 去自己的内存会话管理器中查找对应的 HttpSession 对象。
     - 如果找到了，就把这个已经存在的 HttpSession 对象提供给你的应用程序使用（比如，注入到你的 Controller 方法中）。

  **你不需要写任何代码去解析 Cookie 或查找 Session，你只需要在方法参数里声明你需要 HttpSession，Tomcat 和 Spring Boot 就会把它准备好并递给你。**

### 总结

| 任务                            | 谁来做？                        | 你需要做什么？                                        |
| ------------------------------- | ------------------------------- | ----------------------------------------------------- |
| **创建 Session 和 Session ID**  | **Tomcat (Web 服务器)**         | **什么都不用做**                                      |
| **将 Session ID 发送给浏览器**  | **Tomcat (通过 Set-Cookie 头)** | **什么都不用做**                                      |
| **浏览器保存和发送 Cookie**     | **浏览器**                      | **什么都不用做**                                      |
| **服务器接收并识别 Session ID** | **Tomcat (解析 Cookie 头)**     | **什么都不用做**                                      |
| **使用 Session 存取数据**       | **你 (开发者)**                 | 调用 session.setAttribute() 和 session.getAttribute() |

**你的工作被极大地简化了。** 你只需要把 HttpSession 当成一个神奇的、与每个用户绑定的 Map 来使用。你只管往里面存东西、取东西，而完全不必关心它是如何被创建、传递和识别的。

这就是框架和应用服务器存在的意义——**将复杂的底层细节封装起来，让你能够专注于实现高层的业务逻辑。**

## 过滤器和拦截器

### 拦截器

#### 什么是拦截器？

- **定义**
   拦截器是 **Spring MVC 提供的一种动态拦截请求的机制**，它可以在请求到达 **Controller 之前**、**Controller 执行之后但还没返回给前端时**、以及 **请求完成后** 做一些额外的处理。

- **和过滤器 Filter 的区别**

  | 对比点   | 拦截器（Interceptor）                                       | 过滤器（Filter）                             |
  | -------- | ----------------------------------------------------------- | -------------------------------------------- |
  | 所属     | Spring MVC 提供                                             | Servlet 规范提供                             |
  | 拦截范围 | 只拦截 Spring 管理的请求（比如 DispatcherServlet 里的请求） | 所有请求（包括静态资源）                     |
  | 使用场景 | 登录校验、权限验证、日志打印                                | 编码设置、XSS 过滤、跨域处理                 |
  | 颗粒度   | 更细，能拿到 Handler、ModelAndView 等                       | 较粗，只能拿到 HttpServletRequest / Response |

👉 简单理解：

- **过滤器**是 **大门口的保安**，拦截所有进入 Web 容器的请求。
- **拦截器**是 **Controller 门口的保安**，只拦截 Spring 处理的请求。

------

#### 2. 拦截器能做什么？

常见的用途：

1. **登录验证**：拦截未登录的用户请求，跳转到登录页面。
2. **权限校验**：判断用户是否有权限访问某些资源。
3. **日志记录**：记录接口访问时间、请求参数、响应结果。
4. **性能监控**：统计接口耗时。
5. **接口防刷**：拦截过于频繁的请求。
6. **全局处理**：比如设置一些全局的 request 属性。

------

#### 3. 拦截器的执行流程

一个拦截器类实现 **`HandlerInterceptor`** 接口，有 3 个核心方法：

```java
public interface HandlerInterceptor {
    // 请求进入 Controller 之前
    boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler);

    // Controller 执行后，视图渲染前
    void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView);

    // 整个请求结束之后（渲染视图后）
    void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex);
}
```

- **preHandle**：返回 `true` 才会继续往下执行，返回 `false` 表示拦截请求（比如未登录）。
- **postHandle**：适合做结果加工，比如给 `ModelAndView` 增加通用参数。
- **afterCompletion**：做资源清理，比如关闭线程变量、日志收尾。

👉 流程图：

```
请求进来
   ↓
preHandle()
   ↓（true 才继续）
Controller 执行
   ↓
postHandle()
   ↓
视图渲染
   ↓
afterCompletion()
```

------

#### 4. 如何注册一个拦截器？

在 Spring Boot / Spring MVC 里，需要：

第一步：写一个拦截器类

```java
@Component
public class LoginInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        Object user = request.getSession().getAttribute("user");
        if (user == null) {
            response.sendRedirect("/login"); // 没有登录就跳转
            return false;
        }
        return true; // 已登录，放行
    }
}
```

第二步：配置注册拦截器

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Autowired
    private LoginInterceptor loginInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loginInterceptor)
                .addPathPatterns("/**")         // 拦截所有请求
                .excludePathPatterns("/login", "/static/**"); // 排除某些请求
    }
}
```

------

#### 5. 多个拦截器的执行顺序

如果有多个拦截器，Spring MVC 会 **按注册顺序** 执行：

- **preHandle**：顺序执行（先注册的先执行）。
- **postHandle 和 afterCompletion**：**逆序执行**（先注册的后执行）。

👉 类似责任链模式：

```
拦截器1 preHandle
   ↓
拦截器2 preHandle
   ↓
Controller
   ↓
拦截器2 postHandle
   ↓
拦截器1 postHandle
   ↓
拦截器2 afterCompletion
   ↓
拦截器1 afterCompletion
```

------

#### 6. 重要的知识点 & 注意事项

1. **和 AOP 的区别**
   - 拦截器 → 作用于 **Web 请求**。
   - AOP → 作用于 **方法调用**（不仅限于 Web）。
2. **拦截器只拦截 Spring MVC 处理的请求**
    比如 `DispatcherServlet` 分发的请求。静态资源（HTML、CSS、JS）默认不会被拦截，除非你配置了。
3. **返回 false 的情况**
    如果 `preHandle` 返回 `false`，后续拦截器的 `preHandle` 就不会执行，也不会进入 Controller，但 **已经执行过的拦截器的 afterCompletion 会被调用**，保证资源释放。
4. **常见用法**
   - 登录校验（session/token 校验）。
   - 接口日志（记录请求参数、响应时间）。
   - 防止重复提交（在 preHandle 里加锁）。
5. **Spring Boot 已经封装了 HandlerInterceptorAdapter**
    但从 Spring 5.3 开始，这个适配器被废弃，推荐直接实现 `HandlerInterceptor`。

------

📌 **总结一句话**：

- **拦截器**是 Spring MVC 的“门卫”，可以在请求进入和返回时做增强。
- 适合做权限、日志、性能、校验等场景。
- 注册方式就是实现 `HandlerInterceptor` + `WebMvcConfigurer`。
- 多个拦截器按 **注册顺序 → preHandle 顺序执行，postHandle/afterCompletion 逆序执行**

#### DispatcherServlet(适配器服务)

##### 一、DispatcherServlet 是什么？（一句话定义）

DispatcherServlet 是 Spring MVC 框架的**核心**，它是一个**前端控制器 (Front Controller)**。

- **前端控制器**：这是一个设计模式。意思就是，**所有**的 Web 请求（比如 /user/info, /order/detail）都会先发送到这一个**统一的入口 Servlet**，而不是像早期技术那样为每个 URL 都写一个独立的 Servlet。
- **核心**：它负责接收所有请求，然后根据配置，将请求**分发（Dispatch）**给后续不同的组件进行处理。它自己不处理具体的业务逻辑，而是扮演一个“交通警察”或“总调度员”的角色。

##### 二、为什么需要它？（它解决了什么问题）

在没有 DispatcherServlet 这种模式之前，Web 开发通常是这样的：

- **一个请求对应一个 Servlet**：你需要为 /login 写一个 LoginServlet，为 /register 写一个 RegisterServlet...
- **重复代码**：每个 Servlet 里可能都需要写一遍权限检查、字符编码设置、日志记录等通用逻辑。这导致了大量的代码冗余和维护困难。

DispatcherServlet 的出现完美地解决了这个问题：

1. **集中处理**：所有通用逻辑（如字符编码、文件上传、异常处理）都可以在这个统一的入口处解决，无需在每个业务处理器中重复编写。
2. **解耦**：DispatcherServlet 将请求的接收和具体的业务处理逻辑（也就是你的 Controller）分离开来。DispatcherServlet 负责“调度”，Controller 负责“干活”，各司其职。
3. **流程化**：它定义了一套标准、清晰的请求处理流程，使得整个框架的扩展和维护变得非常容易。我们之前谈到的拦截器（Interceptor）就是在这个流程中被插入进去的。

------



##### 三、它是如何工作的？（核心工作流程）

当一个请求到达 DispatcherServlet 后，它会像流水线一样，按部就班地调用一系列“专家”组件来协同完成工作。

下面是这个流程的简化版，但包含了最重要的步骤：

*(这是一个经典的 Spring MVC 流程图)*

1. **请求到达 DispatcherServlet**：
   客户端发送一个 HTTP 请求（例如 GET /user/1）。Web 容器（如 Tomcat）将这个请求交给 DispatcherServlet。
2. **HandlerMapping (处理器映射器) 寻找 Handler**：
   DispatcherServlet 首先会询问 HandlerMapping：“这个 /user/1 的请求，应该由哪个代码来处理？”
   HandlerMapping 就像一本**地址簿**，它内部维护了所有 URL 路径和处理它们的方法（即 Controller 方法）之间的映射关系。它找到对应的 Controller 方法后，会把这个方法的信息（我们称之为 Handler）返回给 DispatcherServlet。
3. **HandlerAdapter (处理器适配器) 执行 Handler**：
   DispatcherServlet 拿到了 Handler（知道该调用哪个方法了），但它并不知道**如何**调用。因为 Controller 的方法签名千变万化（有的带 @RequestParam，有的带 @RequestBody，有的返回 String，有的返回 Map）。
   这时 HandlerAdapter 就出场了。它像一个**万能翻译官或适配器**，告诉 DispatcherServlet：“我知道怎么调用这个方法，把请求给我，我来帮你执行它。” HandlerAdapter 负责准备参数、调用方法，并接收返回值。
4. **Controller (你的业务代码) 执行**：
   HandlerAdapter 调用你的 Controller 方法。你的代码在这里执行数据库查询、业务计算等核心逻辑，然后返回一个 ModelAndView 对象（或者可以直接返回字符串、JSON对象等）。ModelAndView 包含了两部分信息：
   - **Model**：处理结果数据（比如用户信息）。
   - **View**：一个逻辑视图名（比如 "user-detail"）。
5. **ViewResolver (视图解析器) 解析 View**：
   DispatcherServlet 拿到了 ModelAndView 对象。它会把逻辑视图名（"user-detail"）交给 ViewResolver。
   ViewResolver 就像一个**导航员**，它根据这个逻辑名，解析出真正的视图文件路径（比如 "/WEB-INF/jsp/user-detail.jsp"）。
6. **View (视图) 渲染**：
   DispatcherServlet 知道了最终的视图文件在哪里，也拿到了模型数据。它会调用 View 对象，将 Model 数据填充到视图模板中（这个过程叫**渲染**）。
7. **响应返回客户端**：
   渲染完成后，DispatcherServlet 将最终生成的 HTML 页面作为 HTTP 响应，返回给客户端浏览器。

##### 四、DispatcherServlet 与 Filter、Interceptor 的关系

现在，我们可以把之前讨论的 Filter 和 Interceptor 放到这个流程图中，它们的关系就一目了然了：

```
客户端请求
      |
      v
  [ Filter ]  <-- 在 Servlet 容器层面，比 DispatcherServlet 更早
      |
      v
  [ DispatcherServlet ] (核心调度中心)
      |
      |--> 1. HandlerMapping 查找 Handler
      |
      |--> [ Interceptor.preHandle() ]  <-- 在调用 Controller 之前
      |
      |--> 2. HandlerAdapter 执行 Handler (调用 Controller)
      |         |
      |         v
      |      [ Controller 方法执行 ]
      |         ^
      |         |
      |--> [ Interceptor.postHandle() ] <-- 在 Controller 执行后，视图渲染前
      |
      |--> 3. ViewResolver 解析 View
      |
      |--> 4. View 渲染
      |
      |--> [ Interceptor.afterCompletion() ] <-- 在整个请求完成后
      |
      v
  [ 响应返回 ]
      |
      v
  [ Filter ]  <-- 响应也会经过 Filter
      |
      v
客户端
```

**总结一下这个关系**：

- **Filter** 是 DispatcherServlet 的“门卫”，在请求**进入** DispatcherServlet 之前和响应**离开** DispatcherServlet 之后工作。它不知道 Spring MVC 内部的任何细节。
- **Interceptor** 是 DispatcherServlet 的“内部保安”，它工作在 DispatcherServlet 的**流程之中**，可以精准地在 Controller 执行前后等关键节点进行介入。它能获取到 Spring MVC 的上下文信息（比如即将执行哪个 Controller 方法）。

### 过滤器

#### 1. 什么是过滤器？

- **定义**
   过滤器（`javax.servlet.Filter`）是 **Servlet 规范**中定义的一种组件，属于 **JavaEE 标准**，和 Spring 框架无关。
   它可以对进入 **Servlet 容器（Tomcat、Jetty 等）** 的请求和响应进行过滤、修改或拦截。
- **特点**
  - 作用范围广：所有进入容器的请求都会经过过滤器（包括静态资源）。
  - 是 **最早执行** 的处理器，在请求进入 Spring MVC 之前就起作用。

👉 一句话总结：
 **过滤器是大门口的“保安”，拦截所有请求；拦截器是 Controller 门口的“保安”，只拦截 Spring 管理的请求。**

------

#### 2. 过滤器能做什么？

过滤器属于比较底层的机制，常见用途包括：

1. **统一编码设置**（比如强制 UTF-8，防止乱码）。
2. **登录校验 / 权限校验**（和拦截器类似，但更早）。
3. **请求日志记录**（请求 URL、参数、IP 地址等）。
4. **防止 XSS 攻击**（转义恶意脚本）。
5. **性能监控**（统计请求处理耗时）。
6. **跨域处理（CORS）**（如果不用 Spring 的 CORS 支持，可以在 Filter 里加响应头）。

👉 企业常见场景：**编码过滤器**、**XSS 过滤器**、**请求日志过滤器**。

------

#### 3. 过滤器的执行流程

一个过滤器类实现 `javax.servlet.Filter` 接口，核心有 3 个方法：

```java
public interface Filter {
    void init(FilterConfig filterConfig) throws ServletException; // 初始化

    void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) 
        throws IOException, ServletException; // 请求处理

    void destroy(); // 销毁
}
```

- **init**：服务器启动时调用（只执行一次）。
- **doFilter**：核心方法，每次请求都会调用。
  - `chain.doFilter(request, response)`：放行到下一个过滤器或目标资源。
  - 不调用 `chain.doFilter` 就会“拦截请求”。
- **destroy**：服务器关闭时调用，用于清理资源。

👉 流程图：

```
请求进来
   ↓
过滤器1 doFilter
   ↓
过滤器2 doFilter
   ↓
Servlet / SpringMVC
   ↓
过滤器2 返回
   ↓
过滤器1 返回
   ↓
响应出去
```

------

#### 4. 如何注册一个过滤器？

在 **Spring Boot** 中有两种方式：

##### 方法一：使用 @WebFilter 注解

```java
@WebFilter(urlPatterns = "/*") // 拦截所有请求
public class LogFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest) request;
        System.out.println("请求路径：" + req.getRequestURI());
        chain.doFilter(request, response); // 放行
    }
}
```

⚠️ 注意：要在启动类上加 `@ServletComponentScan` 才能扫描到。

##### 方法二：使用 FilterRegistrationBean（推荐）

```java
@Configuration
public class FilterConfig {
    @Bean
    public FilterRegistrationBean<LogFilter> logFilter() {
        FilterRegistrationBean<LogFilter> registrationBean = new FilterRegistrationBean<>();
        registrationBean.setFilter(new LogFilter());
        registrationBean.addUrlPatterns("/*"); // 拦截路径
        registrationBean.setOrder(1); // 设置优先级，值越小优先级越高
        return registrationBean;
    }
}
```

------

#### 5. 多个过滤器的执行顺序

- **顺序由 `FilterRegistrationBean.setOrder()` 决定**（数字小的先执行）。
- 如果是 `@WebFilter` 注解注册的，则按 **类名的字母顺序**（容器默认规则）。

👉 执行顺序：

```
过滤器1 doFilter
过滤器2 doFilter
Servlet/Controller
过滤器2 返回
过滤器1 返回
```

------

6. 重要的知识点 & 注意事项

1. **和拦截器的区别**

   | 对比点   | 过滤器（Filter）                      | 拦截器（Interceptor）          |
   | -------- | ------------------------------------- | ------------------------------ |
   | 规范     | Servlet 规范                          | Spring 提供                    |
   | 拦截范围 | 所有请求（包括静态资源）              | 只拦截 Spring Controller 请求  |
   | 生命周期 | 容器管理（init → doFilter → destroy） | 由 Spring 容器管理             |
   | 使用场景 | 编码、跨域、XSS、防止 SQL 注入        | 登录校验、权限、日志、性能监控 |

2. **什么时候用过滤器，什么时候用拦截器？**

   - **过滤器**：通用的、和 Spring 无关的逻辑（如编码、跨域、安全过滤）。
   - **拦截器**：依赖 Spring 的业务逻辑（如登录校验、权限控制、接口日志）。

3. **性能注意点**
    过滤器属于请求的最外层，如果逻辑写得过重，会影响所有请求的性能。

4. **常见面试题**

   - 过滤器和拦截器的区别？
   - 过滤器能拦截静态资源吗？（能）
   - 在 Spring Boot 中如何注册过滤器？（@WebFilter / FilterRegistrationBean）

------

#### 7. 企业高频使用的过滤器

1. **CharacterEncodingFilter**（Spring Boot 默认有）：保证请求和响应的字符集为 UTF-8。
2. **HiddenHttpMethodFilter**：支持 `PUT/DELETE` 请求方法（通过 `_method` 参数实现）。
3. **CorsFilter**：解决跨域问题。
4. **XssFilter**（自定义）：防止恶意脚本攻击。
5. **LogFilter**（自定义）：打印请求日志、耗时监控。

------

📌 **总结一句话**：

- **过滤器**是 Servlet 规范的“全局保安”，在请求进入 Spring 前生效，适合做编码、跨域、安全类处理；
- **拦截器**是 Spring MVC 的“局部保安”，在 Controller 前后生效，适合做业务相关的校验与日志。
- 在企业中，二者经常 **搭配使用**：过滤器做“通用防护”，拦截器做“业务逻辑校验”。



## **集群Session共享问题**

#### **1. 遇到的问题**

- **场景：** 想象一下，一个网站为了服务更多人，开了好几个“接待窗口”（Tomcat服务器）。你在1号窗口办了业务（登录了），但下一次系统为了效率，把你指引到了2号窗口。
- **问题：** 2号窗口的“接待员”不认识你，因为你的登录信息只存在1号窗口的“小本本”（Session）上。结果就是，系统认为你没登录，刚才购物车里的东西可能也没了。
- **术语说：** 在集群环境下，每个Tomcat服务器的Session内存是独立的，不互通。负载均衡（NGINX）随机分配请求，会导致Session数据丢失。

#### **2. 理想的解决方案长啥样？**

要解决这个问题，我们需要一个“中央登记处”，而不是让每个窗口自己记小本本。这个“登记处”需要满足几个特点：

- **数据共享：** 所有“窗口”都能访问它，信息是互通的。
- **速度要快 (内存存储)：** 存取信息要像在内存里一样快，不能让用户等半天。
- **结构简单 (Key-Value)：** 就像储物柜，用你的“用户ID”（Key）当钥匙，就能直接拿到你的所有信息（Value），非常高效。

#### **3. 我们的办法：引入Redis**

图中的方案就是引入一个叫 **Redis** 的“超级中央登记处”。

- **工作流程：**
  1. 用户（手机/电脑）发起请求。
  2. “总调度”（NGINX）把请求随便发给一个空闲的“接待窗口”（Tomcat）。
  3. “接待窗口”不再看自己的小本本，而是直接去问 **Redis** 这个“中央登记处”：“嗨，这个用户是谁？登录了吗？”
  4. Redis快速地告诉它用户的登录状态和信息。
- **为什么是Redis？**
  因为它完美满足了我们上面说的三个特点：它是一个所有服务器都能访问的、基于内存的、Key-Value结构的数据库。速度飞快，非常适合做这个“中央登记处”的角色。

#### **总结**

**一句话总结：别让每个服务器自己记账了，找个公共的、速度飞快的“中央账本”（Redis）来统一管理用户登录信息，这样不管用户被分配到哪个服务器，体验都是一致的。**

## 缓存穿透

![image-20250904181435211](E:\Typora picture\image-20250904181435211.png)