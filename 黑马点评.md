# 黑马点评

## 基于session实现短信登陆功能

```java
public Result sendCode(String phone, HttpSession session) {
        //1检验手机号是否正确
        if(!RegexPatterns.PHONE_REGEX.matches(phone)){
            return Result.fail("手机号不匹配");
        }
        //2生成验证码
        String code = RandomUtil.randomNumbers(6);
        //3将验证码放入session中
        session.setAttribute("code",code);
        //4发送验证码
        log.info("验证码是：{}",code);

        return Result.ok();
    }
```

以上是核心逻辑，最主要的就是HttpSession。

1. **首次访问**：当你的浏览器第一次访问网站时，服务器（比如 Tomcat）会创建一个全新的 HttpSession 对象
2. **创建 Session ID**：同时，服务器会生成一个全局唯一的字符串，称为 Session ID
3. **发送 Session ID 给浏览器**：服务器会将这个 Session ID 通过一个叫 Cookie 的东西发送给你的浏览器。这个 Cookie 通常名字叫 JSESSIONID。
4. **浏览器保存 Cookie**：你的浏览器会自动保存这个 JSESSIONID Cookie。
5. **后续访问**：从第二次请求开始，你的浏览器每次访问这个网站时，都会**自动带上**这个 JSESSIONID Cookie。
6. **服务器识别用户**：服务器收到请求后，会读取 Cookie 里的 JSESSIONID，然后根据这个 ID 去内存里找到之前为你创建的那个 HttpSession 对象（用手环钥匙找到你的储物柜）。这样，服务器就“认出”你了！





### **Web 会话技术核心笔记：Cookie, HttpSession & JWT**

#### 核心问题：解决 HTTP 的“健忘症”

HTTP 协议是无状态的，服务器无法区分多次请求是否来自同一个用户。以下三种技术都是为了让服务器能“记住”你。

------



### **1. Cookie (超市积分卡)**

- **是什么？**
  - 服务器存放在**浏览器（客户端）**上的一小块数据（键值对）。
  - 浏览器在后续访问**同一个网站**时，会自动带上这张“卡片”。
- **核心特点：**
  - **存储在客户端**：保存在你的电脑上，所以不安全，不能存敏感信息。
  - **服务器驱动**：由服务器通过 Set-Cookie 指令创建。
  - **有有效期**：可以设置为“关闭浏览器就失效”（会话Cookie），或“在硬盘上存一段时间”（持久Cookie）。
  - **大小受限**：通常不能超过 4KB。
- **一句话总结：** **一张由服务器发行、由浏览器保管和出示的“身份证”或“积分卡”，用于客户端的状态记录。**

------



### **2. HttpSession (游乐园储物柜)**

- **是什么？**
  - 服务器为每个用户在**服务器内存中**创建的一个专属“储物柜”，用来存放该用户的会话数据。
- **工作原理：**
  1. 用户首次访问，服务器创建一个 HttpSession 对象（储物柜）。
  2. 服务器生成一个唯一的 Session ID (储物柜钥匙)。
  3. 服务器通过 **Cookie** 将这个 Session ID 发给浏览器保管。
  4. 浏览器后续访问时，带上存有 Session ID 的 Cookie。
  5. 服务器根据 Session ID 找到对应的储物柜，从而识别用户。
- **核心特点：**
  - **存储在服务器端**：数据安全，可以存敏感信息。
  - **有状态 (Stateful)**：服务器需要为每个用户维护一份数据，消耗内存。
  - **依赖 Cookie**：通常需要 Cookie 来传递 Session ID。
  - **扩展性差**：在多台服务器（集群）环境下需要做额外配置（Session共享），否则会出问题。
- **一句话总结：** **一个在服务器端的“专属储物柜”，通过存放在浏览器Cookie里的“钥匙”（Session ID）来识别主人。**

------



### **3. JWT (贵宾全场通行证)**

- **是什么？**
  - 一个经过加密**签名**的、包含了用户信息的**字符串**。它本身就是一张内容详尽、无法伪造的“通行证”。
- **结构 (三段式)：**
  1. Header (头部)：描述元信息，如签名算法。
  2. Payload (载荷)：存放用户信息（如用户ID、角色），**内容是公开的，不能存密码！**
  3. Signature (签名)：将前两部分加上一个**服务器私钥 (Secret)** 进行加密计算，用于**防伪**。
- **核心特点：**
  - **无状态 (Stateless)**：服务器不需要保存任何会话信息，只负责签发和验证。
  - **信息自包含**：所有必要信息都在 Token 内部，服务器拿到后即可解析使用。
  - **扩展性极好**：天然适用于分布式、微服务架构。
  - **不依赖 Cookie**：可以通过 HTTP 请求头 Authorization 传输，对 App、小程序等各种客户端友好。
- **一句话总结：** **一张由服务器签发、由客户端保管的“防伪通行证”，服务器无需记忆，见证认人。**

### **终极对比**

| 特性         | Cookie                | HttpSession           | JWT                         |
| ------------ | --------------------- | --------------------- | --------------------------- |
| **比喻**     | 积分卡                | 储物柜 + 钥匙         | 贵宾通行证                  |
| **数据位置** | **客户端**            | **服务器端**          | **客户端**                  |
| **状态**     | 客户端状态            | **有状态 (Stateful)** | **无状态 (Stateless)**      |
| **安全性**   | 低 (明文)             | 高                    | 中 (签名防篡改, 载荷公开)   |
| **扩展性**   | -                     | 差                    | **好**                      |
| **适用场景** | 记录偏好、辅助Session | 传统单体Web应用       | **前后端分离、微服务、API** |

创建 Session ID以及发送 Session ID 给浏览器和服务器识别用户需要我们手动写代码吗？

答案是：**完全不需要！这些底层的、繁琐的工作，已经由你使用的技术栈（Web服务器/Servlet容器）为你全自动处理好了。**

你作为开发者，被完美地保护在一个高层次的抽象之后，只需要关心业务逻辑。

让我们揭开这层“魔法”的面纱，看看幕后英雄是谁，以及它是如何工作的。

### 幕后英雄：Web 服务器 / Servlet 容器 (例如 Tomcat)

当你运行一个 Spring Boot 项目时，它内置了一个 Web 服务器，最常见的就是 **Tomcat**。Tomcat 是一个 **Servlet 容器**，它负责处理底层的 HTTP 请求和响应，并管理像 HttpSession 这样的 Web 组件。

**Tomcat 就是那个为你处理所有 Session 细节的“全自动管家”。**

下面是这个“管家”为你自动完成的详细工作流程：

#### 1. 创建 Session ID (全自动)

- **触发时机**：当你的代码第一次尝试获取当前用户的 Session 时。在你的例子中，就是 Spring Boot 准备将 HttpSession session 这个参数注入到你的 Controller 方法时。

- **Tomcat 的动作**：

  1. Tomcat 检查收到的 HTTP 请求中，有没有一个有效的 JSESSIONID Cookie。
  2. 对于一个新用户，请求中**没有**这个 Cookie。
  3. Tomcat 判定这是一个新会话，于是：
     - 在服务器内存中创建一个全新的 HttpSession 对象。
     - 调用内部的算法，生成一个**全局唯一的、足够随机、难以猜测的**字符串作为 Session ID。

  **你完全不需要关心这个 ID 是如何生成的。**

#### 2. 发送 Session ID 给浏览器 (全自动)

- **触发时机**：在处理完你的业务逻辑，准备将 HTTP 响应发送回浏览器之前。

- **Tomcat 的动作**：

  1. Tomcat 会“拦截”即将发出的响应。

  2. 它会自动在 **HTTP 响应头 (Response Header)** 中添加一行 Set-Cookie 指令。这行指令的内容大致如下：

     codeCode

     ```
     Set-Cookie: JSESSIONID=A1B2C3D4E5F6G7H8I9J0K1L2; Path=/; HttpOnly
     ```

  3. 然后，它才把完整的响应（包括你的业务数据和这个 Set-Cookie 头）发送给浏览器。

  **你只需要 return Result.ok();，Tomcat 会自动帮你完成添加 Cookie 的所有工作。**

#### 3. 服务器识别用户 (全自动)

- **触发时机**：当同一个用户发起第二次、第三次...请求时。

- **浏览器和 Tomcat 的配合**：

  1. **浏览器**：在收到上一步的 Set-Cookie 指令后，它会把 JSESSIONID=A1B2C3... 这个 Cookie 保存起来。根据 HTTP 规范，在后续访问同一个网站时，浏览器会**自动地**在 **HTTP 请求头 (Request Header)** 中附带上这个 Cookie：

     codeCode

     ```
     Cookie: JSESSIONID=A1B2C3D4E5F6G7H8I9J0K1L2
     ```

  2. **Tomcat**：当它收到这个新的请求时，它会：

     - 解析请求头，找到 Cookie 字段。
     - 提取出 JSESSIONID 的值 (A1B2C3...)。
     - 拿着这个 ID 去自己的内存会话管理器中查找对应的 HttpSession 对象。
     - 如果找到了，就把这个已经存在的 HttpSession 对象提供给你的应用程序使用（比如，注入到你的 Controller 方法中）。

  **你不需要写任何代码去解析 Cookie 或查找 Session，你只需要在方法参数里声明你需要 HttpSession，Tomcat 和 Spring Boot 就会把它准备好并递给你。**

### 总结

| 任务                            | 谁来做？                        | 你需要做什么？                                        |
| ------------------------------- | ------------------------------- | ----------------------------------------------------- |
| **创建 Session 和 Session ID**  | **Tomcat (Web 服务器)**         | **什么都不用做**                                      |
| **将 Session ID 发送给浏览器**  | **Tomcat (通过 Set-Cookie 头)** | **什么都不用做**                                      |
| **浏览器保存和发送 Cookie**     | **浏览器**                      | **什么都不用做**                                      |
| **服务器接收并识别 Session ID** | **Tomcat (解析 Cookie 头)**     | **什么都不用做**                                      |
| **使用 Session 存取数据**       | **你 (开发者)**                 | 调用 session.setAttribute() 和 session.getAttribute() |

**你的工作被极大地简化了。** 你只需要把 HttpSession 当成一个神奇的、与每个用户绑定的 Map 来使用。你只管往里面存东西、取东西，而完全不必关心它是如何被创建、传递和识别的。

这就是框架和应用服务器存在的意义——**将复杂的底层细节封装起来，让你能够专注于实现高层的业务逻辑。**