# 算法培训

# 基础算法

## 排序

### 快速排序

$$
时间复杂度：nlog_2n
$$

$$
不是很稳定，最差能达到：n^2
$$

利用分治算法和递归的思想，下面是实现思路：

首先设置一个基准，一般设置的都是第一个元素或者最后一个元素，中间的也可以，因为采用的是分治算法的思想，最后递归的肯定是两个数，递归基设置为l==r，这个设置是为了判断是否是一个数进行递归，如果l==r的话，那就证明递归的是一个数了，这时候就不需要进行其他操作了，直接返回掉。

分别从左边和右边遍历数组，左边的话是找到一个大于基准的元素，右边是为了找到一个小于基准的元素。找到后如果满足i<j,那就换一下两个元素的位置。

最后递归l到j和j+1到r。

```c++
#include<bits/stdc++.h>
using namespace std;
void quick_sort(int arr[],int l,int r)
{	
	if(l == r) return;
	int i = l-1;int j = r+1;
	int pivot = arr[(r+l)>>1];//(r+l)>>也可以
	while(i < j)
	{
		do i++; while(arr[i] < pivot);
		do j--; while(arr[j] > pivot);
		if(i < j) swap(arr[i],arr[j]);
	}
	quick_sort(arr,l,j);//如果取i的话会有边界问题,记住这个就行。
	quick_sort(arr,j+1,r);
}
int main()
{
	int a[] = {5,454,64,54,31,3,1,543,13,4};
	int len = sizeof(a)/sizeof(a[0]);
	quick_sort(a,0,len-1);
	for(int t:a)
	{
		printf("%d ",t);
	}
	return 0;
}
```

使用`scanf()`和`printf()`能够节省很多时间

这个时间复杂度和sort是相同的，如果题目只是简单的排序，那直接用sort(),如果使用到这个思想中的某个步骤或者sort()超时，可以尝试这个。

### 归并排序

$$
时间复杂度稳定在：nlog_2n
$$

![](E:\Typora picture\归并排序.webp)

```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 1000010;
int q[N],temp[N];
void merge_sort(int* arr,int l,int r)
{
    if(l>=r) return;
    int mid = (l+r)>>1;
    merge_sort(arr,l,mid); merge_sort(arr,mid+1,r);
    int i = l;j = mid+1,k = 0;
    while(i <= mid && j <= r)
    {
        if(arr[i]<=arr[j]) temp[k++] = arr[i++];
        else temp[k++] = arr[j++];
    }
    while(i <= mid) temp[k++] = arr[i++];
    while(j <= r) temp[k++] = arr[j++];
    for(i = l,j = 0;i <= r;i++,j++) arr[i] = temp[j];
}
int main()
{
	int n;
    scanf("%d",&n);
    for(int i = 0;i < n;i++) scanf("%d",&q[i]);
	return 0;
}
```

## 前缀和

前缀和是为了解决区间内某元素数量之和的问题

2024年7月19日第一次补充：从没想到还会在一维前缀和这里出现问题。补充很简单：前缀数组的第i个元素是数组前i-1个元素之和，不是前i个元素之和。

一维数组:

```cpp
arr[i+1] = arr[i]+arr[i-1];
```

二维数组：

```cpp
arr[i][j] += arr[i-1][j]+arr[i][j-1]-arr[i-1][j-1];
```

二维数组的几何含义:

前i行前j列的所有元素之和。

上面的都是很基础的，接下来求从(x1,y1)到(x2,y2)的之间的部分

<img src="E:\Typora picture\20210418221844586.png" style="zoom:100%;" />

```cpp
res = s[x2][y2]-s[s2][y1-1]-s[x1-1][y2]+s[x1-1][x2-1]
```

一般考试就考这个，遇到二维数组中不是整数而是多个字符的情况下，可以设置多个前缀数组，然后遍历原字符数组，将相应的位置填入1，然后遍历前缀数组，进行前缀求和操作。

## 差分

前缀可以离开差分，但差分离不开前缀。差分是为了解决某个区间或者子矩阵上多次加上或者减去数的操作。

一维数组的差分是前缀的逆运算。

```c++
difference_arr[i] = arr[i]-arr[i-1];
```

应用场景:将一个数组[i,j]区间上的数组加上c，并执行类似操作m次,如果我们单纯的遍历，那么时间复杂度将会很大,利用差分数组,第i个元素加上c,第j+1个元素减去c,然后求出前缀和即可.

2024年7月15日:第一次补充：

首先最tm重要的就是如果你要在同一个数组中直接算出差分的话，那只能倒这来，因为如果你正着来的话算后面的就不对了,因为前面改变了真是惨痛的教训.

还有就是补充一种题,就是假如说给你一个数列，然后每次都可以在某个区间上加上或者减去常数c,然后让你求最少几次这个数列中的数都一样。区间上加减数字，一定是差分。

思路:

首先求出这个数列的差分，要求数列中的数都一样，那么必然差分从2到n全是0，那么问题就转化为，如何将差分的2到n项全部转化为0，首先我们对arr操作时是以区间的形式，所以我们对deff_arr操作时可以在一次内进行加减操作（前提是deff_arr中存在复数和正数）

![](C:\Users\asus\Pictures\Screenshots\Screenshot 2024-07-15 204520.png)

如上图，如果想要将上面的deffere_arr的2到n变为0，我们可以在2处减去2，4处加上2，然后2出减去1，5处加上1.这样过后，2处只剩下了2，3，4，5处都为0,这也是一种新的情况，差分数组中只有正数或者负数，那么要操作的步骤就是整数或者负数和的绝对值.所以说本题的答案就是整数和负数中的最小数加上绝对值的差的绝对值。说人话就是正数和负数最大的那个的绝对值。

在此基础上让你求在在保证最少次数的前提下，最终得到的数列有多少种。这个就是求deffer_arr中1号元素最多有几个，首先开始有一个所以最少是1-------。

因为正负相消这个不影响1号元素，但是当deff_arr中只有正数或者负数时，那么你要减去或者加上相应的值

![](C:\Users\asus\Pictures\Screenshots\Screenshot 2024-07-15 210322.png)

如上图，我们要想将4号位的1变为0，可以将1号位进行相对操作，也可以在最后一号位+1号位上进行相对操作，要是变化的次数最多，那就变化一号位，变化的次数就是abs(abs(正数)，abs(负数));

还有一种思路和这个差不多的题型就是将一个数组经过某段区间的加减操作变为另一个数组，这个就简单了，首先我们将这两个数组相减，得到一个新的数组（谁减谁无所谓）然后让这个数组的差分为0就行了，ok，补充结束。

二维数组没有单独的差分数组,对其本身做出一些改变然后求前缀和就可以得到答案.

二维数组的差分应用场景:将二维数组从(x1,y1)到(x2,y2)的元素多次进行加减操作,然后求出变化以后的数组.

![](E:\Typora picture\20210419025057338.png)

通过这张图联合二维数组前缀的几何意义不难理解,在(x1,y1)处加上某个数c，那么前缀以后(x1,y1)右下部份全部都会加上c,如果我们只需要求(x1,y1)到(x2,y2)上加上数字c,那么可以对其他位置进行一些加减操作.

```c++
arr[x1][y1] += c;
arr[x2+1][y1] -= c;
arr[x1][y2+1] -= c;
arr[x2+1][y2+1] += c;//多减了一次
```

然后求前缀和就可以得到了,如果数据多的话就可以大大减少时间.

## 双指针算法

这是一种思想，一般来说用于一些简单的模拟,很容易想到。再次不做赘述。

2024年7月16号第一次补充:

再次我承认小看了双指针，现在是2024年七月17号，昨天晚上到点就回去了并且昨天晚上没把所有题做完，好在今天早上做完了所有关于双指针算法的题目，下面开始补充:

第一道题：k倍区间,这道题应该算是比较难忘的吧，因为在第二次考试中遇到过，现在来解决。

题目:给出一数组，给出k，如果数组的某连续区间之和是k的倍数，那么称这个区间为K倍区间，求出k倍区间的数量。

首先看到连续区间和直接想到前缀和，现在开始想如果我拿到了这个前缀数组之后要进行怎样的操作呢？我们的目的是求出某段连续区间与k取余等于0，首先想到暴力:

```cpp
for(int i = 0;i < n;i++)
{
    for(int j = i+1;j <= n;j++)
    {
		int deff = prefix[j]-prefix[i];
		if(deff%k == 0) res++;
    }
}
```

这样只能通过一部分的测试案例，表示我们的时间复杂度不够低，有没有其他方法呢?

数学在这里显得至关重要，如果有两个数，他们对k取余得到的余数相等，那么它们之间的差和k取余一定是0。这是至关重要的，现在接着我们前缀和的思路，如果我们把前缀和都和k取余，得到0到k-1之间的数，并且使用hash表记录这个数出现的次数，如果不为0时，就代表前面的几个区间可以分别和这个构成k倍区间那就令res += hash[prefix[i]],下面给出伪代码。

```cpp
int arr[n];
for(int i = 1;i <= n;i++)
{
    scanf("%d",&arr[i]);
    arr[i] = (arr[i]+arr[i-1])%k;//这样就求出了前缀数组并且每个元素都和k取过mol
}
unordered_map<int,int> hash;//hash表统计0到k-1这个几个数分别出现的次数
int res = 0;
for(int i = 1;i <= n;i++)
{
    if(hash[prefix[i]] == 0)
    {
        hash[prefix[i]]++;
    }
    else
    {
        res += hash[prefix[i]];
        hash[prefix[i]]++;
    }
}
//讲一下for循环中的逻辑，如果hash[prefix[i]] == 0，表示之前没有出现过这个余数,那么你遍历到的这个就不能和任何构成k倍区间，那就直接令hash表中的这个数的出现次数加一就行。如果hash[prefix[i]] ！= 0那就代表之前出现过几次这个相同的余数，本次遍历的就可以和这几次构成k倍区间，因此令res += hash[prefix[i]],注意不要忘记令hash[prefix[i]]++。
//但是当你自信满满的提交代码时，你会发现报错了，原因就是忽略了一种情况，就是本身就能被k整除，就是长度为一的k倍区间，这个只需要在输入的时候判断一下就可以了.
```

数对：

给出一串正整数数列以及一个正整数 *C*，要求计算出所有满足 *A*−*B*=*C* 的数对的个数。

本题我刚开始使用的是双指针模拟。下面给出图解:

```cpp
数c = 1
1   1   2   3
i

1   1   2   3
j

int res = 0;
for(int i = 0,j = 0;i < n;)
{
    int defe = arr[i]-arr[j];
    if(defe < c)
    {
        i++;
        j = 0;//防止j指向的不是0
    }
    else if(defe == c)
    {
        j++;
        res ++;
    }
    else
    {
        j++;
    }
}
```

这个代码直接拿了76分的高分，于是我要寻求一种更高级的算法。仔细观察发现A-B = C(A,B都属于数组arr)，那么A是不是等于B+C或者说B是不是等于A-C,那么我只需要找到arr中B+C的数量或者arr中A-C的数量不就行了吗，快速查找肯定用hash表啊，下面给出代码

```cpp
int main()
{
    int n,c;scanf("%d%d",&n,&c);
    vector<int> v(n);
    unordered_map<int,int> hash;
    for(int i = 0;i < n;i++)
    {
        scanf("%d",&v[i]);
        hash[v[i]]++;
    }
    int res = 0;
    for(int i = 0;i < n;i++)
    {
        int ans = v[i]-c;//或者v[i]+c
        if(hash.find(ans) != hash.end())
        {
            res += hash[ans];
        }
    }
    cout<<res;
    return 0;
}
```

最长不含重复字符的子字符串

请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含从 `a` 到 `z` 的字符。

本题很奇妙，我现在只了解个方法具体的了解估计要沉淀几天，万能的chatgpt告诉我这是什么滑动窗口，不过我看后面有这个内容，所以先拖一拖。

```cpp
class Solution {
public:
    int longestSubstringWithoutDuplication(string s) {
    unordered_map<char,int> hash;
	int maxx = 0;
	for(int i = 0,j = 0;j < (int)s.size();j++)
	{
		hash[s[j]]++;
		while(hash[s[j]]>1)
		{
			hash[s[i]]--;
			i++;
		}
		maxx = max(maxx,j-i+1);
	}
	return maxx;
    }
};
```

2025年2月19日更新：

[分享丨【题单】滑动窗口与双指针（定长/不定长/单序列/双序列/三指针/分组循环） - 力扣（LeetCode）](https://leetcode.cn/circle/discuss/0viNMK/)

### 滑动窗口算法：

1.定长区间滑动

对于定长区间滑动算法，简单题有相似的模板和思路：首先先算一种最初情况的区间，这里提到一个累加函数reduce(.begin(),.end());然后用一个循环来限制左侧区间的位置不断利用你最初的区间来+或者-，然后得到以某个区间结尾的值。然后根据题目要求计算你需要的即可。



2.不定长区间滑动

这是评论区大哥给的模板，非常好用。

```cpp
//外层循环扩展右边界，内层循环扩展左边界
for (int l = 0, r = 0 ; r < n ; r++) {
	//当前考虑的元素
	while (l <= r && check()) {//区间[left,right]不符合题意
        //扩展左边界
    }
    //区间[left,right]符合题意，统计相关信息
}
```

注意在存在删除操作时，一定要搞好顺序关系，否则将会出错!!!

## 区间合并

终于遇到个简单的。给定几个区间的连续数，将所有重叠的区间进行合并。

这种题是有固定的方法的

```cpp
//使用vector<pair<int,int>> 储存所有区间
//需要一个vector<pair<int,int>> 储存合并后的区间after
//使用sort升序
//第三步:
pair<int,int> current = arr[0];
for(int i = 1;i < n;i++)
{
    if(arr[i].first <= current.second)
    {
        current.second = max(current.second,arr[i].second);
        //之所以不直接等于arr[i].second是为了防止[1,10],[2,5]这种情况
    }
    //区间不能够合并了,那我先将合并好的区间推入after,然后重新定义current区间为arr[i]
    else
    {
        after.push_back(current);
        current = arr[i];
    }
}
after.push_back(current);//别忘记了最后要推入最后一个区间，你可以理解为总共n个区间，进行了n-1次操作最后一下要推入操作好的区间，也可以举个例子试试
```

好了，把发的有关区间合并的题都做完了，只能说很一般，都是靠上面哪个模板通吃。下面补充几点：

1如果遇到求合并后的总长度的问题，那就不用再定义一个向量，只需要将推入after的操作变成res += current.second-current.first，加一与否要看具体题目，还有别忘了最后也要有这一步

## 位运算

现在是2024年7月17日，真是糟糕，想了一上午位运算，到10点20为止才想出了一道题，不过好在了解了有关一些位运算的性质。

| 符号 | 描述 | 运算规则                                                     |
| :--- | :--- | :----------------------------------------------------------- |
| &    | 与   | 两个位都为1时，结果才为1                                     |
| \|   | 或   | 两个位都为0时，结果才为0                                     |
| ^    | 异或 | 两个位相同为0，相异为1                                       |
| ~    | 取反 | 0变1，1变0                                                   |
| <<   | 左移 | 各二进位全部左移若干位，高位丢弃，低位补0（相当于将10进制数增大2倍） |
| >>   | 右移 | 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移），相当于将10进制数除了2 |

异或的几条性质:

- 1、交换律
- 2、结合律 (a^b)^c == a^(b^c)
- 3、对于任何数x，都有 x^x=0，x^0=x
- 4、自反性: a^b^b=a^0=a;

复制的就是爽!

感觉这些有关位运算的题就是有一定的思考方向的，就是掌握了几种就可以解决很多问题，上题

题目·：二进制中1的个数

给出n个数，分别求出对应二进制数1的个数

```cpp
假如说有一个二进制数
0 1 1 0 1 1 0 0 0    那么我将这个数减去一得到
0 1 1 0 1 0 1 1 1    就是将最后一个一变为了0，然后我们让这两个数取与运算
0 1 1 0 1 0 0 0 0	我们发现前面的不变，然后有一个1变为了0
所以代码就是:
int res = 0;
while(num!=0)
{
    num &= (num-1);
    res++;
}
```

题目:只出现一次的数字:（同样适用于只出现奇数次的数字）

给出n个数，让你求出出现1次或者说奇数次的数字

```cpp
这个题目我们用到了异或^的性质
那我们模拟一下过程
1 2 2 3 3 3 1 0 0 2 3
这是一列数我们令res = 0;因为0^x = x;
不断读入数据进行异或操作
while(n--)
{
    res ^= temp;
}
/*
刚开始是0^1 = 1
然后 1^2	1^2^2(满足结合律x^x = 0)所以最终答案是1	1^3 1^3^3=1 1^3 1^3^1=3 3^0^0=3 3^2 3^2^3=2
*/
```





## 二分查找（完整版）

使用二分查找的条件：连续性和有界性

对整数的二分查找可以分为两类，第一类是获得目标值最前面的的元素的索引，第二类是获得目标值最后面的元素的索引，这里要强调的是如果数组中只含有一个目标值，那么用这两个代码哪个都可以。

```cpp
int get_ans(const vector<int>& v, int target) {
    int left = 0;
    int right = v.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (v[mid] == target) {
            right = mid - 1; // 在找到目标之后依旧使区间向左边搜索，这是为了找到第一次出现的索引
        } else if (v[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    // 如果找到了目标元素,则返回第一次出现的索引加 1
    if (left < v.size() && v[right] == target) {
        return left + 1;
    } else {
        return -1;
    }
}

```

```cpp
int get_ans(const vector<int>& v, int target) {
    int left = 0;
    int right = v.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (v[mid] == target) {
            left = mid + 1; // 继续在右半部分搜索
        } else if (v[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    // 如果找到了目标元素,则返回最后一次出现的索引加 1
    if (right >= 0 && v[right] == target) {
        return right + 1;
    } else {
        return -1;
    }
}
```

仔细观察不难发现上面两个代码是有区别的，就是while的判断条件是否加上等号，而这两个代码除了这个都一样，表示while循环中有没有等号都一样。今天是2024年7月18日，万能的chatgpt4-o告诉我循环条件最好是<=,小于可能会越界(虽然他给我举得两个例子都没越界)。

经过长达两个半小时的努力，我终于领悟到了真谛。假如说你是要找最后一次出现的，设想l和r都指向了这个最后一次出现的元素，然后mid肯定也等于这个元素，根据你找最后一个的思想，那我肯定继续向右搜索，那么l = 最后一个出现的位置+1，而经历完这个后l = r+1,循环条件就不满足了，那么循环结束，r才是指向正确的位置。我简直是天才！！！

找最后一个输出左边的是一样的道理。

现在是2024年7月21日第一次补充：额，其实上面的版本不是完整版。还有一个浮点数二分。但是这个不是很常见。

```cpp
bool check()
{
}
int main()
{
    double l,r;
    //l,r是答案的所在的区间
    double exp = 1e-6;//比题目给出的要小两个数量级
    while(r-l>exp)//有没有等于也不知道有啥区别，但是chatgpt说最后不加
    {
        double mid = (l+r)/2;
        if(check(mid)) r = mid;
        else l = mid;
    }
    printf("%.4lf",l);//这里输出l或者r都可以，但是一般是l
    return 0;
}
```

现在是2025年三月5日，上面的二分除了浮点数都是答辩，下面才是硬货：

```cpp
二分查找都是在有序的序列中找的
所以说我们可以做一些剪枝操作
//
    
    
    
if(!len) return -1;长度为0，找不到
if(nums[0]>target) return -1;//最小的都比target大，找不到
if(nums[len-1]<target) return -1;//最大的都比target小，找不到



int l = 0,r = len-1;
//>=target的第一个位置
while(l <= r)
{
    int mid = l+(r-l)/2;
    if(nums[mid]>=target)//满足条件
    {//如果是找第一个的话
        r = mid-1;
    }else l = mid+1;   
}
//闭区间二分查找最后一次循环肯定是l==r==答案
也就是说最后一次循环还会进行一次满足条件的代码，如果是找第一个，那么r==mid-1，所以说答案是l
//当然也可以直接记住答案，最左l,最右r
    
    
//>target的第一个位置
while(l<=r)
{
    int mid = l+(r-l)/2;
    if(nums[mid]>target){//满足条件,找第一个
        r = mid-1;
    }else l = mid+1;
}



//<=target的第一个位置
while(l<=r)
{
    int mid = l+(r-l)/2;
    if(nums[mid]<=target)
    {
        r = mid-1;
    }else l = mid+1;
}
```

我来总结二分五部曲：

第一：剪枝操作不要少（解释一下原因：如果说你要找一个>=target的下标，但是这里面最大的数小于了target，那么返回的肯定是len,这时候你去判断num[l]就会出错，所以说最好不要省掉，当然如果在最判断一下l的取值范围也可以，不过这显然不是最明智的方法）

第二：二分框架往里套

第三：if里面写满足

第四：最初最末很重要

第五：最初l,最末r,判断结果是必要

我nm就是天才



还有一种找负数的有点奇妙，一会补充；

一个排序好的数组nums，里面存在负数，如果我要找第一个<=0的元素，该怎么找呢？这样其实就是找最后一次出现的《=0的元素，直接套公式就行

## 离散化

这个怎么说呢，就做了一道题感觉还可以，这个本质就是映射，将不连续的数字映射为连续的数字。并且使用这个方法做题的时候，前30行代码都是模板，必须要写的，后面才有一点点自己需要思考的过程。

给出这种题的题目大致模板，有一个很长的数轴，上面全是0，然后进行几次（相比较于数轴的长度来说）加减操作，后面的就比较自由了，比如说和前缀和联系在一起，让你求某个区间之和。

题目描述

小e有一个很长很长的数组，数组的下标范围为 [0, 10^9]，初始时每个元素均为 0。

现在，他想进行 n 次操作，每次操作将某个下标 i 处的元素加上 x。

然后他给出了 q 次询问，每个询问格式为 l r，你需要回答出下标在区间 [l, r] 内的所有元素的和。

输入描述

第一行：两个整数 n, q。（1 ≤ n, q ≤ 10^5）

接下来 n 行：每行两个整数 i, x。（0 ≤ i ≤ 10^9，0 ≤ x ≤ 10^4）

再接下来 q 行：每行两个整数 l, r。（0 ≤ l ≤ r ≤ 10^9）

输出描述

共 q 行，每行输出相应询问的答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	int n,q;cin>>n>>q;
	vector<int> pos(n),add(n);
	vector<pair<int,int>> query(q);
	vector<int> yuan;
	for(int i = 0;i < n;i++)
	{
		cin>>pos[i]>>add[i];
		yuan.push_back(pos[i]);
	}
	for(int i = 0;i < q;i++)
	{
		cin>>query[i].first>>query[i].second;
		yuan.push_back(query[i].first);
		yuan.push_back(query[i].second);
	}
	sort(yuan.begin(),yuan.end());
	yuan.erase(unique(yuan.begin(),yuan.end()),yuan.end());
	unordered_map<int,int> hash;
	int len = yuan.size();
	for(int i = 0;i < len;i++)
	{
		hash[yuan[i]] = i;
	}
	vector<int> com_arr(len);
	for(int i = 0;i < n;i++)
	{
		int index = hash[pos[i]];
		com_arr[index] += add[i];
	}
	for(int i = 1;i < len;i++)
	{
		com_arr[i] += com_arr[i-1];
	}
	for(auto pi : query)
	{
		int l = hash[pi.first];
		int r = hash[pi.second];
		int res;
		if(l == 0)
		{
			res = com_arr[r];
		}
		else
		{
			res = com_arr[r]-com_arr[l-1];
		}
		cout<<res<<endl;
	}
	return 0;
}
```

大概就是这样，ok了，本来想做第三道题，发现要用到并查集，然后并查集是后面学的内容，所以以后再说；

## ST（稀疏表)

今天是2024年7月22日，看了两天也没看懂稀疏表，好在这个东西有固定的模板，并且只适用于固定的题型。那就先套模板，以后大脑在强一点再深入理解。

ST 表（Sparse Table）是一种用于解决区间最值查询（RMQ，Range Minimum Query）的问题的高效数据结构。ST 表主要用于静态数组（即数组元素在构建后不再改变）的场景，具有快速查询和预处理的特点。

不只是区间最小问题还有区间最大问题，或者说区间极差问题。

`f(i,j)`表示`i`到`i+2^j-1`的最大值。所以说遍历的时候行的条件是`i+2^j-1<n`，取不到等于是因为是从第0列开始读入数据的，他的范围在`n-1`

```cpp
	void buildSparseTable(vector<int>& arr, vector<vector<int>>& st) {
    int n = arr.size();
    int k = log2(n) + 1;
    st.assign(n, vector<int>(k, INT_MAX));
    
    for (int i = 0; i < n; i++) {
        st[i][0] = arr[i];
    }
    
    for (int j = 1; (1 << j) <= n; j++) {
        for (int i = 0; (i + (1 << j) - 1) < n; i++) {
            st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);//求最大值的话返回max
        }
    }
}
int query(const vector<vector<int>>& st, int L, int R) {
    int j = log2(R - L + 1);
    return min(st[L][j], st[R - (1 << j) + 1][j]);//求最大值的话返回max
}
```

上面的是使用vector去做的，但是有时候这个过不了，那就使用静态数组去做。

```cpp
const int N = 1000;  // 假设最大数组长度为1000
int arr[N];          // 输入数组
int st[N][(int)log2(N) + 1];  // ST 表，列数动态计算
// 构建 ST 表
void buildSparseTable(int n) {
    int K = log2(n) + 1;  // 动态计算 K
    // 初始化 ST 表的第一列
    for (int i = 0; i < n; i++) {
        st[i][0] = arr[i];
    }
    // 填充 ST 表
    for (int j = 1; (1 << j) <= n; j++) {
        for (int i = 0; (i + (1 << j) - 1) < n; i++) {
            st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
        }
    }
}
// 区间最小值查询
int query(int L, int R) {
    int j = log2(R - L + 1);
    return min(st[L][j], st[R - (1 << j) + 1][j]);
}
```

使用 `vector` 和使用普通数组之间的时间差距在大多数情况下是非常小的，特别是对于像 ST 表这样的算法，主要的时间复杂度是由算法的逻辑本身决定的，而不是数据结构的选择。所以说就用vector简单。

模拟过程：

```ini
arr = [9, 5, 8, 4, 7, 8, 6, 2]
```

```css
st[0][0] = 9
st[1][0] = 5
st[2][0] = 8
st[3][0] = 4
st[4][0] = 7
st[5][0] = 8
st[6][0] = 6
st[7][0] = 2
```

```apl
st[0][1] = min(st[0][0], st[1][0]) = min(9, 5) = 5
st[1][1] = min(st[1][0], st[2][0]) = min(5, 8) = 5
st[2][1] = min(st[2][0], st[3][0]) = min(8, 4) = 4
st[3][1] = min(st[3][0], st[4][0]) = min(4, 7) = 4
st[4][1] = min(st[4][0], st[5][0]) = min(7, 8) = 7
st[5][1] = min(st[5][0], st[6][0]) = min(8, 6) = 6
st[6][1] = min(st[6][0], st[7][0]) = min(6, 2) = 2
```

```css
st[0][2] = min(st[0][1], st[2][1]) = min(5, 4) = 4
st[1][2] = min(st[1][1], st[3][1]) = min(5, 4) = 4
st[2][2] = min(st[2][1], st[4][1]) = min(4, 7) = 4
st[3][2] = min(st[3][1], st[5][1]) = min(4, 6) = 4
```

```css
     j=0   j=1   j=2
st[0]  9     5     4
st[1]  5     5     4
st[2]  8     4     4
st[3]  4     4     4
st[4]  7     7     -
st[5]  8     6     -
st[6]  6     2     -
st[7]  2     -     -
```



## 三分

先空着有时间补。



# 数据结构

## queue

由于队列`queue`是一种先进先出的限制性的数据结构，因此`STL`中只能通过`front()`来访问队首元素，或是通过`back()`来访问队尾元素，`push()`是入队操作

入队操作最好使用`emplace`而不是`push`，因为前者会在队列的末尾直接构造数据，如果仅仅是`int`或者`char`这些简单的类型还好，如果说队列中是`pair`或者更复杂的数据结构，那么差异就体现出来了

`pop`弹出队首元素

`front`获得队首元素

`back`获得队尾元素

`empty`和`size`就不多说了

## priority_queue

优先队列，底层使用堆来写，但是如果你问我堆是什么，那我只能说是一种数据结构要自己写的那种。优先队列还是比较简单的去理解，并且他的内置函数也不多。先来讲讲为什么叫做优先队列，因为他会自动把优先级最高的元素排在最前面，那么如果有排序的算法，不用sort可以用这个装13。开玩笑。

首先，优先队列不能使用索引或者说是下标去访问。

其次，优先队列创建时有三个参数第一个是类型，第二个是要使用的底层容器（默认为vector），第三个是优先级问题默认是less,是以大的为最优先的，可以改为greater。这样就变成了以最小为最优先的，

函数:

+ push:推入
+ pop弹出
+ top获取优先级最高的
+ size返回大小
+ empty是否为空

就这几个。

## set

`std::set` 是 C++ 标准模板库 (STL) 提供的一个集合容器，它存储键值并自动排序，同时保证元素的唯一性。`std::set` 提供了一些有用的操作和方法，下面是有关 `std::set` 的所有操作的详细介绍。

### 基本操作

1. **创建和初始化**

   ```cpp
   std::set<int> s1; // 默认构造函数
   std::set<int> s2 = {1, 2, 3, 4}; // 列表初始化
   std::set<int> s3(s2); // 拷贝构造函数
   std::set<int> s4(s2.begin(), s2.end()); // 迭代器范围构造函数
   ```

2. **插入元素**

   ```cpp
   s1.insert(5); // 插入单个元素
   s1.insert({6, 7, 8}); // 插入初始化列表中的元素
   s1.insert(s2.begin(), s2.end()); // 插入迭代器范围内的元素
   ```

3. **删除元素**

   ```cpp
   s1.erase(5); // 删除值为 5 的元素
   s1.erase(s1.begin()); // 删除第一个元素
   s1.erase(s1.begin(), s1.find(8)); // 删除迭代器范围内的元素
   s1.clear(); // 删除所有元素
   ```

4. **查找元素**

   ```cpp
   auto it = s1.find(5); // 返回指向值为 5 的元素的迭代器，若找不到则返回 s1.end()
   bool exists = s1.count(5); // 若存在值为 5 的元素，则返回 1，否则返回 0
   ```

5. **大小和容量**

   ```cpp
   bool isEmpty = s1.empty(); // 若集合为空则返回 true
   size_t size = s1.size(); // 返回集合中元素的数量
   ```

6. **访问元素**

   ```cpp
   auto it = s1.begin(); // 返回指向第一个元素的迭代器
   auto it = s1.end(); // 返回指向最后一个元素之后的位置的迭代器
   auto it = s1.rbegin(); // 返回指向最后一个元素的反向迭代器
   auto it = s1.rend(); // 返回指向第一个元素之前的位置的反向迭代器
   ```

7. **范围操作**

   ```cpp
   auto lower = s1.lower_bound(3); // 返回指向第一个不小于 3 的元素的迭代器
   auto upper = s1.upper_bound(3); // 返回指向第一个大于 3 的元素的迭代器
   auto range = s1.equal_range(3); // 返回一个范围，包含所有值为 3 的元素的迭代器对
   ```

### 常见用法示例

1. **遍历集合**

   ```cpp
   for (const auto& elem : s1) {
       std::cout << elem << " ";
   }
   std::cout << std::endl;
   
   for (auto it = s1.begin(); it != s1.end(); ++it) {
       std::cout << *it << " ";
   }
   std::cout << std::endl;
   ```

2. **合并两个集合**

   ```cpp
   std::set<int> s3 = {4, 5, 6};
   s1.insert(s3.begin(), s3.end());
   ```

3. **交集操作**

   ```cpp
   std::set<int> s3 = {4, 5, 6};
   std::set<int> intersection;
   std::set_intersection(s1.begin(), s1.end(), s3.begin(), s3.end(),
                         std::inserter(intersection, intersection.begin()));
   ```

4. **并集操作**

   ```cpp
   std::set<int> s3 = {4, 5, 6};
   std::set<int> union_set;
   std::set_union(s1.begin(), s1.end(), s3.begin(), s3.end(),
                  std::inserter(union_set, union_set.begin()));
   ```

5. **差集操作**

   ```cpp
   std::set<int> s3 = {4, 5, 6};
   std::set<int> difference;
   std::set_difference(s1.begin(), s1.end(), s3.begin(), s3.end(),
                       std::inserter(difference, difference.begin()));
   ```

### `std::set` 特性

- **自动排序**：`std::set` 中的元素是自动排序的，默认情况下使用 `<` 运算符。可以通过自定义比较器来更改排序规则。
- **唯一性**：`std::set` 保证所有元素的唯一性，插入重复元素时不会添加新元素。
- **底层实现**：`std::set` 通常使用红黑树 (Red-Black Tree) 作为底层数据结构，以保证插入、删除、查找操作的时间复杂度为 O(log n)。

### 自定义比较器

如果需要按自定义规则排序，可以提供自定义比较器：

```cpp
struct CustomCompare {
    bool operator()(const int& lhs, const int& rhs) const {
        return lhs > rhs; // 降序排序
    }
};
std::set<int, CustomCompare> customSet = {1, 2, 3, 4, 5};
```

## unordered_set

实现：基于哈希表（hash table）

元素顺序：不保证元素的顺序。
查找时间复杂度：平均情况下为 O(1)，最坏情况下为 O(n)（当哈希冲突较多时）。
插入和删除时间复杂度：平均情况下为 O(1)，最坏情况下为 O(n)。
使用场景：适合需要快速查找、插入和删除的场景，但不关心元素的顺序。
set
实现：基于红黑树（自平衡的二叉搜索树）。
元素顺序：按照元素的升序排列（默认情况下）。
查找时间复杂度：O(log n)。
插入和删除时间复杂度：O(log n)。
使用场景：适合需要保持元素有序的场景，比如需要频繁进行范围查询的情况。
总结
如果你需要快速的查找和插入操作，并且不关心元素的顺序，选择 unordered_set。
如果你需要保持元素的顺序，并且可以接受较慢的查找和插入速度，选择 set。

## map

`std::map` 是 C++ 标准模板库 (STL) 提供的一个关联容器，用于存储键值对，并且根据键自动排序。它类似于其他编程语言中的字典或哈希表。下面是有关 `std::map` 的所有操作的详细介绍。

### 基本操作

1. **创建和初始化**

   ```cpp
   std::map<int, std::string> m1; // 默认构造函数
   std::map<int, std::string> m2 = {{1, "one"}, {2, "two"}}; // 列表初始化
   std::map<int, std::string> m3(m2); // 拷贝构造函数
   std::map<int, std::string> m4(m2.begin(), m2.end()); // 迭代器范围构造函数
   ```

2. **插入元素**

   ```cpp
   m1.insert(std::make_pair(1, "one")); // 插入单个元素
   m1.insert({2, "two"}); // 使用列表初始化插入
   m1[3] = "three"; // 使用下标操作符插入
   m1.insert(m2.begin(), m2.end()); // 插入迭代器范围内的元素
   ```

3. **删除元素**

   ```cpp
   m1.erase(1); // 删除键为 1 的元素
   m1.erase(m1.begin()); // 删除第一个元素
   m1.erase(m1.begin(), m1.find(3)); // 删除迭代器范围内的元素
   m1.clear(); // 删除所有元素
   ```

4. **查找元素**

   ```cpp
   auto it = m1.find(2); // 返回指向键为 2 的元素的迭代器，若找不到则返回 m1.end()
   bool exists = m1.count(2); // 若存在键为 2 的元素，则返回 1，否则返回 0
   ```

5. **大小和容量**

   ```cpp
   bool isEmpty = m1.empty(); // 若 map 为空则返回 true
   size_t size = m1.size(); // 返回 map 中元素的数量
   ```

6. **访问元素**

   ```cpp
   auto it = m1.begin(); // 返回指向第一个元素的迭代器
   auto it = m1.end(); // 返回指向最后一个元素之后的位置的迭代器
   auto it = m1.rbegin(); // 返回指向最后一个元素的反向迭代器
   auto it = m1.rend(); // 返回指向第一个元素之前的位置的反向迭代器
   ```

7. **元素访问**

   ```cpp
   std::string value = m1[2]; // 使用下标操作符访问值
   auto it = m1.find(2);
   if (it != m1.end()) {
       std::string value = it->second; // 通过迭代器访问值
   }
   ```

8. **范围操作**

   ```cpp
   auto lower = m1.lower_bound(2); // 返回指向第一个不小于 2 的键的迭代器
   auto upper = m1.upper_bound(2); // 返回指向第一个大于 2 的键的迭代器
   auto range = m1.equal_range(2); // 返回键为 2 的范围的迭代器对
   ```

### 常见用法示例

1. **遍历 `map`**

   ```cpp
   for (const auto& pair : m1) {
       std::cout << pair.first << " : " << pair.second << std::endl;
   }
   
   for (auto it = m1.begin(); it != m1.end(); ++it) {
       std::cout << it->first << " : " << it->second << std::endl;
   }
   ```

2. **合并两个 `map`**

   ```cpp
   std::map<int, std::string> m3 = {{3, "three"}, {4, "four"}};
   m1.insert(m3.begin(), m3.end());
   ```

3. **查找或插入元素**

   ```cpp
   auto result = m1.insert({5, "five"});
   if (result.second) {
       std::cout << "Insertion successful" << std::endl;
   } else {
       std::cout << "Element already exists" << std::endl;
   }
   ```

4. **自定义比较器**

   ```cpp
   struct CustomCompare {
       bool operator()(const int& lhs, const int& rhs) const {
           return lhs > rhs; // 降序排序
       }
   };
   
   std::map<int, std::string, CustomCompare> customMap = {{1, "one"}, {2, "two"}};
   ```

### `std::map` 特性

- **自动排序**：`std::map` 中的元素是根据键自动排序的，默认情况下使用 `<` 运算符。可以通过自定义比较器来更改排序规则。
- **唯一键**：`std::map` 保证所有键的唯一性，插入重复键时不会添加新元素，而是更新现有元素的值。
- **底层实现**：`std::map` 通常使用红黑树 (Red-Black Tree) 作为底层数据结构，以保证插入、删除、查找操作的时间复杂度为 O(log n)。

## list(双向链表)

```cpp
#include <iostream>
#include <list>
int main() {
    // 创建一个空的 list
    std::list<int> mylist;

    // 插入元素到 list 末尾
    mylist.push_back(10);
    mylist.push_back(20);
    mylist.push_back(30);

    // 插入元素到 list 头部
    mylist.push_front(5);

    // 打印 list 中的元素
    for(int val : mylist) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    // 删除 list 末尾的元素
    mylist.pop_back();

    // 删除 list 头部的元素
    mylist.pop_front();

    // 打印 list 中的元素
    for(int val : mylist) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

插入和删除操作

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> mylist = {10, 20, 30, 40, 50};

    // 使用迭代器插入元素
    auto it = mylist.begin();
    std::advance(it, 2); // 将迭代器移动到第三个位置
    mylist.insert(it, 25);

    // 打印 list 中的元素
    for(int val : mylist) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    // 使用迭代器删除元素
    it = mylist.begin();
    std::advance(it, 3); // 将迭代器移动到第四个位置
    mylist.erase(it);//返回值是被删除元素的下一位

    // 打印 list 中的元素
    for(int val : mylist) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> mylist = {10, 20, 30, 40, 50};

    // 反转 list
    mylist.reverse();

    // 打印反转后的 list
    for(int val : mylist) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    // 排序 list
    mylist.sort();

    // 打印排序后的 list
    for(int val : mylist) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    // 移除所有值为 20 的元素
    mylist.remove(20);

    // 打印 list 中的元素
    for(int val : mylist) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    // 移除所有满足特定条件的元素 (大于 30)
    mylist.remove_if([](int val) { return val > 30; });

    // 打印 list 中的元素
    for(int val : mylist) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

在某个位置修改元素

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> mylist = {10, 20, 30, 40, 50};

    // 使用迭代器访问和修改任意位置的元素
    auto it = mylist.begin();
    std::advance(it, 2); // 将迭代器移动到第三个位置
    *it = 35;

    // 打印修改后的 list
    std::cout << "After modification: ";
    for(int val : mylist) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

## KMP字符串匹配算法

首先要了解KMP解决的是一类什么样的问题，就是从一个文本中找出目标串target第一次出现的索引，顺带解决一个最大相同前后缀的问题。

这个问题比较不好想，我是今天几乎想了一天不是特别明白，勉强可以把代码写出来。

```cpp
vector<int> prefix(string &target)//求出前缀数组
{
    int m = target.length();
    vector<int> pi(m,0);
    int j = 0;
    for(int i = 1;i < m;i++)
    {
        while(target[i]!=target[j]&&j > 0)
        {
            j = pi[j-1];
        }
        if(target[i]==target[j]) j++;
        pi[i] = j;
    }
    return pi;
}
vector<int> KMP(string &text,string &target,vector<int> &pi)
{
    int n = text.length();
    int m = target.length();
    int j = 0;
    vector<int> res;
    for(int i = 0;i < n;i++)
    {
        while(target[j] != text[i]&&j > 0)
        {
            j = pi[j-1];
        }
        if(target[j] == text[i]) j++;
        if(j == m)
        {
            res.push_back(i-m+1);
            j = pi[j-1];
        }
    }
    return res;//这里的索引是从0开始的
}
```

模板是对的，提交试过了。

现在是2024年10.26日，我突然发现一个KMP的另一种写法，这个模板太难记了，直接自创新的写法。

```cpp
vector<int> computeNext(const string &target) {
    int m = target.length();
    vector<int> next(m);
    next[0] = 0; // 第一个元素总是0
    int i = 1;   // 从第二个字符开始
    int j = 0;   // 前缀长度

    while (i < m) {
        if (target[i] == target[j]) {
            next[i] = j+1; // 记录前缀长度
            i++，j++;        // 移动到下一个字符
        } else {
            if (j > 0) {
                j = next[j - 1]; // 回退到上一个可能的匹配前缀
            } else {
                next[i] = 0; // 没有前缀
                i++;         // 移动到下一个字符
            }
        }
    }

    return next;
}

vector<int> KMP(string &text, string &target, vector<int> &pi) {
    int m = target.length();
    int n = text.length();
    vector<int> positions; // 用于存储所有匹配的位置
    int j = 0, i = 0;
    
    while (i < n) {
        if (text[i] == target[j]) {
            i++;
            j++;
            if (j == m) {
                positions.push_back(i - j); // 找到匹配，记录位置
                j = pi[j - 1]; // 继续查找下一个可能的匹配
                //这个如何理解呢？这时候j已经指向了一个模式串最后的后一位，这是不存在的，因此相当于text[i] ！= target[j]，而j肯定是大于0的，所以j直接等于pi[j-1]。
            }
        } else {
            if (j > 0) {
                j = pi[j - 1];
            } else {
                i++;
            }
        }
    }
    
    return positions; // 返回所有匹配的位置
}
```



## 字典树

C++中的字典树（Trie）是一种用于高效存储和查找字符串集合的数据结构。它特别适合于处理**字符串前缀匹配的问题。**

### 字典树的基本概念

1. **节点**：字典树中的每个节点表示一个字符。
2. **根节点**：字典树的起始点，不包含任何字符。
3. **边**：从一个节点到另一个节点的路径代表一个字符。
4. **单词终结标志**：一个特殊的标志，用于标识一个单词的结尾。

### 字典树的基本操作

1. **插入（Insert）**：将一个单词插入字典树中。
2. **查找（Search）**：查找一个单词是否在字典树中。
3. **前缀查找（Prefix Search）**：查找以某个前缀开头的所有单词。

```cpp
struct node
{
	bool isend = false;
	unordered_map<char,node*> child;
};
struct Trie
{
	node* root = new node;
	void insert(const string &s)
	{
		node* cur_node = root;
		for(char c:s)
		{
			if(cur_node->child.find(c) == cur_node->child.end())
			{
				cur_node->child[c] = new node;
			}
			cur_node = cur_node->child[c];
		}
		cur_node->isend = true;
	}
	bool search(const string &s)
	{
		node* cur_node = root;
		for(char c: s)
		{
			if(cur_node->child.find(c) == cur_node->child.end())	return false;
			cur_node = cur_node->child[c];
		}
		if(cur_node->isend) return true;
		else return false;
	}
	bool prefix(const string &s)
	{
		node* cur_node = root;
		for(char c: s)
		{
			if(cur_node->child.find(c) == cur_node->child.end()) return false;
			cur_node = cur_node->child[c];
		}
		return true;
	}
	
};
```

看了一眼代码感觉还行，再看一遍，有望今天学会。现在是9.17.OK，现在是9.54，已经重写了字典树，这个算是比较简单的了，开始做题。

ok,做了一个模板提题，这个题是让你求前缀的，所以我们就不用写search函数了，但其实search和prefix差不多，就复制过来改一下就行了，然后这个题没过的原因是他让你求的是前缀出现的次数，不是是否出现，那么我们就不需要isend了，而需要一个计数器tot来记录每个单词出现的次数，最后求前缀的时候直接返回最后一个模式串出现的次数即可。拿下拿下！！！

## 并查集（数据结构）

并查集的问题最终可以模型化为给定一系列连续的数字，给定操作，讲数字连续到一起，然后给出询问两个数字是否是在一起。如果给定的不是数字呢？hash表啊孩子。

下面这个算是比较完美的并查集了。

```cpp
struct ufset
{
private:
	vector<int> father;
	vector<int> len;
public:
	ufset(int n)
    {
		father.resize(n);
		len.resize(n,1);
		for(int i = 0;i < n;++i) father[i] = i;
	}
	int find(int x)
	{
		if(father[x] != x)
		{
			father[x] = find(father[x]);
		}
		return father[x];
	}
	bool issame(int x,int y)
	{
		return (find(x)==find(y));
	}
	void merge(int x,int y)
	{
        int rootx = find(x);
        int rooty = find(y);
        if(rootx==rooty) return;
		if(len[rootx]<=len[rooty])
			{
				father[rootx] = rooty;
				len[rooty] += len[rootx];
			}
			else{
				father[rooty] = rootx;
				len[rootx] += len[rooty];
			}
	}
};
```

# 搜索与图论基础

## `dfs`和`bfs`

`dfs和bfs`实际上是一种思想和方法，这个需要不断地去刷题保持，但是我也是有一定的思考的。

首先，`dfs`采用递归或者栈实现，一般使用递归，因为代码好写。但是要保持对递归的理解，思考问题时要想到下一层是什么状态，最后一层是什么状态，开始返回的时候是什么状态，还要注意回溯的时候保持原样。下面以最经典的八皇后问题来演示思考过程以及做题步骤。dfs也可以说是暴力搜索，枚举所有满足条件的情况。

步骤一：设置需要用到达容器和变量

```cpp
int n;
vector<vector<string>> solu;//这个储存所有方法
vector<string> board;//这个代表棋盘
vector<int> lie;//判断当前列是否满足条件
vector<int> pie,na;//判断正对角线和反对角线是否满足条件
int main(){
    cin>>n;
    board.resize(n,string(n,'.'));//初始化最开始的布局，n行n列全为.
    lie.resize(n,0);//初始化总共n列，全是0，表示可以放置，放上后改变为1，不推荐使用vector+bool
    na.resize(2*n,0);//捺这个对角线上的元素的横纵坐标规律是i-j相等（最小是1-n,最大n-1），为了不出现负数我们让他加上n
    pie.resize(2*n,0);//撇这个对角线上的元素坐标相加为定值，不难得出最大值是2n-2,我们设置为2n也是绰绰有余。
    return 0;
}
```

步骤二：构思dfs函数

```cpp
//首先可以想到的是我们要从第0行开始直到搜到第n-1行结束因为第n-1行也需要搜索，所以我们的递归基设置为if(行==n)....
//至于参数我们应该如何设置呢？一开始不知道怎么设置，我们需要用到什么就传入什么。
void dfs(int row){//按行搜索和设置递归基都需要用到当前行数，所以我们传入当前行数。
    if(row == n){//这里代表已经找到了一个答案，我们推入solu
        solu.emplace(board);
        return;
    }
}
for(int i = 0;i < n;i++){
    if(lie[i]||pie[i+j]||na[i-j+n]) continue;//只要有一个不满足条件就不能在这里放，我们就继续下个位置。
    board[row][i] = 'Q';//满足放的条件了，将棋盘上的这个.换为Q
    lie[i]=pie[i+j]=na[i-j+n]=1;//放置了后适当位置改为1
    dfs(row+1);//搜索下一行
    //是不是以为到这里就没了，其实还有个最重要的就是回溯，回溯过程要求你想到递归的递进的最后一个状态或者说是回归的第一个状态
    //设想row已经到达了n并且solu已经储存了解决方案，那就开始返回了上个状态就是row = n-1的状态，并且会接着执行dfs之后的代码，如果你什么都不做的话，将会继续遍历第n-1行试图找出其他答案，可是你的lie,pie,na依旧记录着前面的一种结果，所以我们开始回溯
    board[row][i] = '.';
    lie[i]=pie[i+j]=na[i-j+n]=0;
    //欧克
}
```

我称bfs为扩散，其实使用bfs主要是为了解决最短或者最少诸如此类的问题，他的核心就是扩散，从一个点扩散到所有满足的点，使用对列实现，本身不难。

## 图的储存

## 邻接矩阵

使用一个二维数组 `adj` 来存边，其中 `adj[u][v]` 为 1 表示存在 ![u](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 到 ![v](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的边，为 0 表示不存在。如果是带边权的图，可以在 `adj[u][v]` 中存储u到 v 的边的边权。

```cpp
int n, m;
vector<int> vis;
vector<vector<int> > adj;
//查询两个点之间是否有边
bool find_edge(int u, int v) { return adj[u][v]; }
//遍历和u有关的所有点，如果需要计数的话添加计数器tot
void dfs(int u) {
  if (vis[u]) return;
  vis[u] = 1;
  for (int v = 1; v <= n; ++v) {
    if (adj[u][v]) {
      dfs(v);
    }
  }
}

int main() {
  cin >> n >> m;

  vis.resize(n + 1, 0);
  adj.resize(n + 1, vector<int>(n + 1,0));

  for (int i = 1; i <= m; ++i) {
    int u, v;
    cin >> u >> v;
    adj[u][v] = 1;//如果有权的的话这里直接赋值为权，带权图
  }

  return 0;
}
```

复杂度

查询是否存在某条边：O(1)

遍历一个点的所有出边：O(n)

遍历整张图：O(n^2)

空间复杂度：O(n^2)

应用

邻接矩阵只适用于没有重边（或重边可以忽略）的情况。

**其最显著的优点是可以O(1)查询一条边是否存在。**

由于邻接矩阵在稀疏图上效率很低（尤其是在点数较多的图上，空间无法承受），所以一般只会在稠密图上使用邻接矩阵。

## 邻接表

方法

使用一个支持动态增加元素的数据结构构成的数组，如 `vector<int> adj[n + 1]` 来存边，其中 `adj[u]` 存储的是点 ![u](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的所有出边的相关信息（终点、边权等)。

```cpp
int n, m;
vector<int> vis;
vector<vector<int> > adj;
//查询两个点之间是否有关系
bool find_edge(int u, int v) {
  for (int i = 0; i < adj[u].size(); ++i) {
    if (adj[u][i] == v) {
      return true;
    }
  }
  return false;
}
//这个是搜索和u节点所有有关的子节点
void dfs(int u) {
  if (vis[u]) return;
  vis[u] = 1;
  for (int i = 0; i < adj[u].size(); ++i) dfs(adj[u][i]);
}

int main() {
  cin >> n >> m;

  vis.resize(n + 1, 0);
  adj.resize(n + 1);

  for (int i = 1; i <= m; ++i) {
    int u, v;
    cin >> u >> v;
    adj[u].push_back(v);
  }

  return 0;
}
```

应用：

存各种图都很适合，除非有特殊需求（如需要快速查询一条边是否存在，且点数较少，可以使用邻接矩阵）。

尤其适用于需要对一个点的所有出边进行排序的场合。

# 动态规划

我以为不难，结果很不好想象的东西。

## 01背包

给出容量为V的背包，给出n个商品，接下来分别给出n个商品的体积和价值，让你求背包最大可以装价值为多少的东西。

二维:

```cpp
int v,n;
cin>>v>>n;
vector<int> w(n+1),v(n+1);
vector<vector<int>> dp(n+1,vector<int>(v+1));
//dp[i][j]的含义是前i个商品在容量为j的情况下所能取到的最大价值。
//这里要留意的是，我们空出了一行和一列，这有助于帮我们减少在特定情况下讨论的情况。但是有时后空出来的这两行不一定都是0，要看具体情况具体分析。但是在这里就都是0，比如说第一列空间为0，最大价值也就是0.第一行一样
for(int i = 1;i <= n;i++) cin>>w[i]>>v[i];
for(int i = 1;i <= n;i++){
    for(int j = 1;j <= v;j++){
        if(w[i]>j) dp[i][j] = dp[i-1][j]l//当前物品重量超过背包容量
        else{
            dp[i][j] = max(dp[i-1][j],dp[i-1][j-v[i]]+w[i]);//当前物品重量未超过背包容量，从选还是不选这两种情况中取最大
        }
    }
}
```

一维:

```cpp
int v,n;
cin>>v>>n;
vector<int> w(n+1),v(n+1);
vector<int> dp(j=+1);//使用一维数组，减少空间。dp[j]表示背包容量为j时所装物品价值最大的情况
for(int i = 1;i <= n;i++) cin>>w[i]>>v[i];
for(int i = 1;i <= n;i++){
 	for(int j = v;j >= v[i];j--){//为啥这里要倒着呢？
        dp[j] = max(dp[j],dp[j-v[i]]+w[i]);
    }   
}
```

如果我们从最小的背包容量开始考虑放物品（即正序遍历），那么在更新较大的背包容量 `j` 时，较小的背包容量 `j-v[i]` 可能已经考虑过了物品 `i`。这会导致物品 `i` 被错误地计算两次，即它在更新 `f[j-v[i]]` 时被考虑过一次，在更新 `f[j]` 时又被考虑。因为逆序是从大到小考虑，所以，并不会发生上述重复考虑的情况

## 完全背包

完全背包和01背包的区别就是完全背包每个商品有无数个，而01背包只有一个。

二维:

```cpp
int v,n;
cin>>v>>n;
vector<int> w(n+1),v(n+1);
vector<vector<int>> dp(n+1,vector<int>(v+1));
for(int i = 1;i <= n;i++) cin>>w[i]>>v[i];
for(int i = 1;i <= n;i++){
    for(int j = 1;j <= v;j++){
        if(v[i]>j) dp[i][j] = dp[i-1][j];
        else{
            dp[i][j] = max(dp[i-1][j],dp[i][j-v[i]]+w[i]);//这里有区别，因为有无限多个，所以即使拿走了一个，依旧还是要从前i个商品中取体积为j-v[i]容量最大值。很好理解吧，01背包只有一个，取走了只能从前i-1个商品中取的j-v[i]的最大值
        }
    }
}
```

一维:

```cpp
int v,n;
cin>>v>>n;
vector<int> w(n+1),v(n+1);
vector<int> dp(v+1);
for(int i = 1;i <= n;i++) cin>>w[i]>>v[i];
//依旧是一个商品一个商品来
for(int i = 1;i <= n;i++){
    for(int j = v[i];j <= v;j++){//这里为什么要使用正序遍历呢？
    	dp[j] = max(dp[j],dp[j-v[i]]+w[i]); 	   
    }
}
```

还是和商品数量有关，01背包中逆序遍历是因为物品数量只有一个，前面的对某个物品做出选择后，这个物品就没了，但是后面的某个空间可能会用到这个这个已经改变过的最大价值了，所以说不行。但是完全背包有无限个，所以正序可以考虑的每一种情况。其实我自己也不是很理解，只是有个模模糊糊的感觉。

## 多重背包

完了啊，今天是2024年8月4号，是动态规划测试，tmd我就学了个01背包和完全背包的模板，题是一道都不会。还是研究多重背包吧。

多重背包这里直接上二进制优化了，就是每一个数都可以表示为2的k次方+某个最后的数。这里要注意多重背包数量都是有限的，没有无穷的情况，有无穷的应该叫做混合背包，我们一会会讲。

实际上这种情况就是讲数量不断地划分，当成01背包的情况，所以只要一些小改变加上01背包的模板即可

```cpp
int multiKnapsack(int n, int C, vector<int>& weights, vector<int>& values, vector<int>& quantities) {
    vector<int> dp(C + 1, 0);

    // 遍历每一种物品
    for (int i = 0; i < n; ++i) {
        int weight = weights[i];
        int value = values[i];
        int quantity = quantities[i];

        // 二进制分解数量
        int k = 1;
        while (quantity > 0) {
            int num = min(k, quantity);
            quantity -= num;//这里是减去num，不是减去k，因为你选定的是num
            // 处理分解出来的每一个物品
            for (int j = C; j >= num * weight; --j) {
                dp[j] = max(dp[j], dp[j - num * weight] + num * value);
            }
            k *= 2; // 翻倍
        }
    }

    return dp[C];
}
```

讲一下二进制分解数量，就是不断的取二的次方，如果剩下的数量大于了当前二的次方，那就取走2的次方然后对动态规划数组进行填充，否则就把剩下的全部取走进行填充。怎么说呢，就相当于把一个7个数量的物品不断划分分为了1，2，4这3个不同的物品，说白了就是将问题转化为了01背包。

## 混合背包

混合背包就是在多重背包的基础上加上了一个条件：某个物品的数量可能是无穷多个，处理的方法也很简单，我们肯定是遍历每个物品，与多重背包不同的是，如果某个物品数量是无穷的，我们要单独解决。

```cpp
int knapsack(int n, int C, vector<int>& weights, vector<int>& values, vector<int>& quantities) {
    vector<int> dp(C + 1, 0);
    for (int i = 0; i < n; ++i) {
        int weight = weights[i];
        int value = values[i];
        int quantity = quantities[i];

        if (quantity == -1) {  // 无限数量
            for (int j = weight; j <= C; ++j) {
                dp[j] = max(dp[j], dp[j - weight] + value);
            }
        } else {  // 有限数量
            int k = 1;
            while (quantity > 0) {
                int num = min(k, quantity);
                quantity -= num;           
                // 处理分解出来的每一个物品
                for (int j = C; j >= num * weight; --j) {
                    dp[j] = max(dp[j], dp[j - num * weight] + num * value);
                }
                k *= 2; // 翻倍
            }
        }
    }
    return dp[C];
}
```

## 分组背包

在分组背包问题中，物品被分成若干组，每组最多只能选择一个物品。目标是选择若干物品，使得总重量不超过背包容量且总价值最大。

现在是2024年8月5号4.44分，嗯，其实我也不知道为什么讲每组分别使用01背包的板子就可以求出答案，哎。

思路就是遍历每一组，然后使用01板子就行了。？？？不对，我就感觉有问题，首先就是01背包问题是外层是遍历所有的物品，内层是遍历所有的空间，但是这个是最外层遍历组，第二层遍历空间，最后一层才是遍历每个物品，差别在这里，那么
