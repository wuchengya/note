# 代码量

```cpp
2024年10.10
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef __int128 lll;
using pii = pair<int,int>;
using vecii = vector<vector<int>>;
bool check(int weishu,int num1,int num2)
{
	int temp = num2%(int)pow(10,weishu);
	if(num1==temp) return true;
	return false;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL),cout.tie(NULL);
	int n,q;
	cin>>n>>q;
	vector<int> arrn(n);
	vector<pii> arrq(q);
	for(int i = 0;i < n;i++) cin>>arrn[i];
	sort(arrn.begin(),arrn.end());
	for(int i = 0;i < q;i++){
		cin>>arrq[i].first>>arrq[i].second;
	}
	vector<int> res(q,-1);
	for(int i = 0;i < q;i++)
	{
		for(int j = 0;j < n;j++)
		{
			if(arrq[i].second>arrn[j]) continue;
			else if(check(arrq[i].first,arrq[i].second,arrn[j])){
				res[i] = arrn[j];
				break;
			}
		}
	}
	for(auto &t:res)
	{
		cout<<t<<endl;
	}
	return 0;
}
2024年10.11
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL), cout.tie(NULL);
	
	string res = "";
	for(int i = 1;i < 501;i++)
	{
		res += to_string(i);
	}
	int n;cin>>n;
	vector<vector<char>> arr(n,vector<char>(2*n-1,'.'));
	int x = 0,y = n-1;
	while(x<n-1)
	{
		arr[x][y] = res[0];
		res.erase(res.begin());
		x++;
		y--;
	}
	for(int i = 0;i < 2*n-1;i++)
	{
		arr[n-1][i] = res[0];
		res.erase(res.begin());
	}
	x = n-2;
	y = 2*n-3;
	while(x>0)
	{
		arr[x][y] = res[0];
		res.erase(res.begin());
		x--;
		y--;
	}
	for(int i = n-2;i>=0;i--)
	{
		for(int j = 2*n-2;j > 0;j--)
		{
			if(arr[i][j]=='.') arr[i][j] = ' ';
			else break;
		}
	}
	for(auto i:arr)
	{
		for(auto j: i)
		{
			cout<<j;
		}
		cout<<endl;
	}
	return 0;
}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef __int128 lll;
using pii = pair<int,int>;
using vecii = vector<vector<int>>;


int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL),cout.tie(NULL);
	set<int> res;
	int n,d,k;
	cin>>n>>d>>k;
	unordered_map<int,vector<int>> hash;
	while(n--)
	{
		int ti,lo;
		cin>>ti>>lo;
		hash[lo].push_back(ti);
	}
	for(auto &t:hash)
	{
		if(t.second.size()<k) continue;
		sort(t.second.begin(),t.second.end());
		int i = 0,j = 0;
		int len = t.second.size();
		while(i < len&&j < len)
		{
			while(t.second[j]-t.second[i]<d&&j < len)
			{
				j++;
			}
			if(j-i>=k)
			{
				res.insert(t.first);
			}
			i++;
		}
	}
	for(int i:res) cout<<i<<endl;
	return 0;
}
2024年10.12
    /**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *l3 = new ListNode(-1);
        int jinzhi = 0;
        while(l1&&l2)
        {
            int tot = l1->val+l2->val+jinzhi;
            jinzhi = tot/10;
            ListNode *temp = new ListNode(tot%10);
            ListNode *t = l3;
            while(t->next)
            {
                t = t->next;
            }
            t->next = temp;
            l1 = l1->next;
            l2 = l2->next;
        }
        if(!l1&&!l2&&jinzhi)
        {
            ListNode *temp = new ListNode(1);
            ListNode *t = l3;
            while(t->next)
            {
                t = t->next;
            }
            t->next = temp;
        }
        if(l1)
        {
            while(l1)
            {
                int tot = l1->val+jinzhi;
                jinzhi = tot/10;
                ListNode *temp = new ListNode(tot%10);
                ListNode *t = l3;
                while(t->next)
                {
                    t = t->next;
                }
                t->next = temp;
                l1 = l1->next;
            }
            if(jinzhi)
            {
                ListNode *temp = new ListNode(1);
                ListNode *t = l3;
                while(t->next)
                {
                    t = t->next;
                }
                t->next = temp;
            }
        }
        if(l2)
        {
            while(l2)
            {
                int tot = l2->val+jinzhi;
                jinzhi = tot/10;
                ListNode *temp = new ListNode(tot%10);
                ListNode *t = l3;
                while(t->next)
                {
                    t = t->next;
                }
                t->next = temp;
                l2 = l2->next;
            }
            if(jinzhi)
            {
                ListNode *temp = new ListNode(1);
                ListNode *t = l3;
                while(t->next)
                {
                    t = t->next;
                }
                t->next = temp;
            }
        }
        l3 = l3->next;
        return l3;
    }
};
2024年10.15
#include<bits/stdc++.h>
using namespace std;
int n,k,tot;
vector<int> nums;
bool is_prime(int num){
	if(num < 2) return false;
	for(int i = 2;i <= sqrt(num);i++){
		if(num%i==0) return false;
	}
	return true;
}
void dfs(int pos,int sum,int times){
	if(times == k){
		if(is_prime(sum)) tot++;
		return ;
	}
	for(int i = pos;i < n;i++){
		dfs(i+1,sum+nums[i],times+1);
	}
}

int main(){
	cin>>n>>k;
	nums.resize(n);
	for(int i = 0;i < n;i++) cin>>nums[i];
	dfs(0,0,0);
	cout<<tot;
	return 0;
}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef __int128 lll;
using pii = pair<int,int>;
vector<vector<int>> arr;
int mov_x[] = {0,0,-1,1},mov_y[] = {1,-1,0,0};
int n;
bool is_legal(int x,int y)
{
  return x>=0&&x<n&&y>=0&&y<n;
}
void dfs(int x,int y)
{
  arr[x][y] = -1;
  for(int i = 0;i < 4;i++)
  {
    if(is_legal(x+mov_x[i],y+mov_y[i])&&arr[x+mov_x[i]][y+mov_y[i]]==0){
      dfs(x+mov_x[i],y+mov_y[i]);
    }
  }
}
int main()
{
  ios::sync_with_stdio(false);
  cin.tie(nullptr),cout.tie(nullptr);
  cin>>n;
  arr.resize(n,vector<int>(n));
  for(int i = 0;i < n;i++){
    for(int j = 0;j < n;j++)
    {
      cin>>arr[i][j];
    }
  }
  for(int i = 0;i < n;i++)
  {
    if(arr[0][i]==0) dfs(0,i);
    if(arr[n-1][i]==0) dfs(n-1,i);
    if(arr[i][0]==0) dfs(i,0);
    if(arr[i][n-1]==0) dfs(i,n-1);
  }
  for(int i = 0;i < n;i++){
    for(int j = 0;j < n;j++)
    {
      if(arr[i][j]==0) arr[i][j] = 2;
      if(arr[i][j]==-1) arr[i][j] = 0;
    }
  }
  for(int i = 0;i < n;i++){
    for(int j = 0;j < n;j++)
    {
      cout<<arr[i][j]<<" ";
    }
    cout<<endl;
  }
  return 0;
}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef __int128 lll;
using pii = pair<int,int>;
int n,m;
vector<vector<int>> qipan;
bool is_legal(int x,int y)
{
	return x>=0&&x<n&&y>=0&&y<m;
}
int movx[] = {2,2,-2,-2,1,1,-1,-1};
int movy[] = {1,-1,1,-1,2,-2,2,-2};
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr),cout.tie(nullptr);
	cin>>n>>m;
	int x,y;
	cin>>x>>y;
	x--,y--;
	qipan.resize(n,vector<int>(m,-1));
	qipan[x][y] = 0;
	queue<pii> q;
	q.emplace(x,y);
	while(!q.empty())
	{
		auto [a,b] = q.front();
		q.pop();
		for(int i = 0;i < 8;i++)
		{
			int isa = a+movx[i];
			int isb = b+movy[i];
			if(is_legal(isa,isb)&&qipan[isa][isb]==-1)
			{
				q.emplace(isa,isb); 
				qipan[isa][isb] = qipan[a][b]+1;
			}
		} 
	}
	for(int i = 0;i < n;i++)
	{
		for(int j = 0;j < m;j++)
		{
			cout<<qipan[i][j]<<' ';
		}
		cout<<endl;
	}
	return 0;
}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
using pii = pair<int,int>;

int n;
vector<int> hang, lie, you, zuo;
vector<vector<int>> res;
vector<int> temp;

void dfs(int cengshu) {
    if (cengshu == n) { // 这里改为 n，表示成功放置了 n 个皇后
        res.push_back(temp);
        return;
    }
    for (int i = 0; i < n; i++) {
        if (hang[cengshu] && lie[i] && zuo[cengshu + i] && you[n + i - cengshu]) {
            hang[cengshu] = 0;
            lie[i] = 0;
            zuo[cengshu + i] = 0;
            you[n + i - cengshu] = 0;
            temp.push_back(i + 1); // 存储皇后放置的列（1-based）
            dfs(cengshu + 1);
            // 回溯
            hang[cengshu] = 1;
            lie[i] = 1;
            zuo[cengshu + i] = 1;
            you[n + i - cengshu] = 1;
            temp.pop_back();
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    cin >> n;
    hang.resize(n, 1); // 改为 n
    lie.resize(n, 1);  // 改为 n
    you.resize(2 * n, 1);
    zuo.resize(2 * n, 1);
    dfs(0);
    for (auto &one : res) {
        for (auto &two : one) {
            cout << two << " ";
        }
        cout << endl;
    }
    return 0;
}
class Solution {
public:
	int maxArea(vector<int>& height) {
		int res = 0;
		int len = height.size();
		for(int i = 0;i < len-1;i++)
		{
			for(int j = len-1;j > i;j--)
			{
				if(height[j]<height[i])
				{
					res = max(res,min(height[j],height[i])*(j-i));
				}
				else{
					res = max(res,min(height[j],height[i])*(j-i));
					break;
				}
			}
		}
		return res;
	}
};
class Solution {
public:
    bool check(vector<string>& strs,int len)
    {
        string stand = strs[0].substr(0,len);
        for(int i = 1;i < strs.size();i++)
        {
            if(strs[i].substr(0,len)!=stand) return false;
        }
        return true;
    }
    string longestCommonPrefix(vector<string>& strs) {
        int min_len = 300;
        int len = strs.size();
        if(len==0)return "";
        for(int i = 0;i < len;i++)
        {
            if(strs[i].size()<min_len) min_len = strs[i].size();
        }
        int left = 0,right = min_len;
        while(left<=right)
        {
            int mid = (right-left)/2+left;
            if(check(strs,mid))
            {
                left = mid+1;
            }else{
                right = mid-1;
            }
        }
        return strs[0].substr(0,right);
    }
};
class Solution {
public:
    unordered_map<char,vector<char>> hash;
    vector<string> res;
    string temp;
    void dfs(int n,string goal,int now)
    {
        if(now == n)
        {
            res.emplace_back(temp);
            return;
        }
        for(int i = 0;i < hash[goal[now]].size();i++)
        {
            temp.push_back(hash[goal[now]][i]);
            dfs(n,goal,now+1);
            temp.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        hash['2'].push_back('a');
        hash['2'].push_back('b');
        hash['2'].push_back('c');
        hash['3'].push_back('d');
        hash['3'].push_back('e');
        hash['3'].push_back('f');
        hash['4'].push_back('g');
        hash['4'].push_back('h');
        hash['4'].push_back('i');
        hash['5'].push_back('j');
        hash['5'].push_back('k');
        hash['5'].push_back('l');
        hash['6'].push_back('m');
        hash['6'].push_back('n');
        hash['6'].push_back('o');
        hash['7'].push_back('p');
        hash['7'].push_back('q');
        hash['7'].push_back('r');
        hash['7'].push_back('s');
        hash['8'].push_back('t');
        hash['8'].push_back('u');
        hash['8'].push_back('v');
        hash['9'].push_back('w');
        hash['9'].push_back('x');
        hash['9'].push_back('y');
        hash['9'].push_back('z');
        int len = digits.length();
        if(!len) return res;
        dfs(len,digits,0);
        return res;
    }
};
class Solution {
public:
    string res = "";
    vector<string> ge = {"I","II","III","IV","V","VI","VII","VIII","IX"};
    vector<string> shi = {"X","XX","XXX","XL","L","LX","LXX","LXXX","XC"};
    vector<string> bai = {"C","CC","CCC","CD","D","DC","DCC","DCCC","CM"};
    vector<string> qian = {"M","MM","MMM"};
    string intToRoman(int num) {
        int k = 0;
        if(!num) return res;
        while(num)
        {
            int temp = (int)num%10*pow(10.0,k);
            k++;
            num = num/10;
            if(temp==0) continue;
            if(temp>0&&temp<10)
            {
                res.insert(0,ge[temp-1]);
            }
            else if(temp>=10&&temp<=90)
            {
                temp = temp/10;
                res.insert(0,shi[temp-1]);
            }
            else if(temp>=100&&temp<=900)
            {
                temp = temp/100;
                res.insert(0,bai[temp-1]);
            }
            else{
                temp = temp/1000;
                res.insert(0,qian[temp-1]);
            }
        }
        return res;
    }
};
class Solution {
public:
    int romanToInt(string s) {
        int len = s.length();
        bool v = true,l = true,d = true,m = true;
        int res = 0;
        for(int i = len-1;i >= 0;i--)
        {
            if(s[i]=='I')
            {
                if(v)
                {
                    res += 1;
                }
                else{
                    res -= 1;
                }
            }
            else if(s[i]=='V')
            {
                res += 5;
                v = false;
            }
            else if(s[i]=='X')
            {
                if(i>=1&&s[i-1]=='I')
                {
                    s[i-1] = ' ';
                    res += 9;
                    continue;
                }
                if(l) res += 10;
                else res -= 10;
            }
            else if(s[i]=='L')
            {
                res += 50;
                l = false;
            }
            else if(s[i]=='C')
            {
                if(i>=1&&s[i-1]=='X')
                {
                    s[i-1] = ' ';
                    res += 90;
                    continue;
                }
                if(d) res += 100;
                else res -= 100;
            }
            else if(s[i]=='D')
            {
                res += 500;
                d = false;
            }
            else if(s[i]=='M')
            {
                if(i>=1&&s[i-1]=='C')
                {
                    res += 900;
                    s[i-1] = ' ';
                    continue;
                }
                res += 1000;
                m = false;
            }
        }
        return res;
    }
};
class Solution {
public:
    int findWinningPlayer(vector<int>& skills, int k) {
        int len = skills.size();
        int i = 0,j = 1;
        int tot = 0;
        while(true)
        {
            if(skills[i]>skills[j])
            {
                j++;
                if(j==len) return i;
                tot++;
                if(tot==k) return i;
            }
            else
            {
                tot = 1;
                if(tot == k) return j;
                i = j;
                j = i+1;
                if(j == len) return i;
            }
        }
    }
};
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode *res = new ListNode;
        ListNode *temp = res;
        while(list1&&list2)
        {
            if(list1->val<=list2->val)
            {
                res -> next = list1;
                list1 = list1->next;
            }
            else
            {
                res -> next = list2;
                list2 = list2->next;
            }
            res = res->next;
        }
        if(list1)
        {
            res -> next = list1;
        }
        if(list2) res->next = list2;
        temp = temp->next;
        return temp;
        
    }
};
```

