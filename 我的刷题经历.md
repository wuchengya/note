# 我的刷题经历

## 2024年10.10

今天是排序算法[9.图书管理员 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/344/learning/?page=1&first_category_id=1&tags=冒泡排序,排序,归并排序,快速排序,桶排序&tag_relation=union)

这题也真是逆天，题意都不说清楚，害我错了好几次。

+ 注意事项一：求一个整数的最后几位数字可以直接使用%的方法，我刚开始是使用了字符串的方法逆置的方法，感觉都可以吧，如果不给出位数的话还是我的好一点，给出的话%好一点。
+ 注意初始化操作，因为定义长度错误我找了半天原因。
+ 有些情况下可以不使用额外空间，一边输入一边运算一边输出。可以节省代码和空间。

## 2024年10.11

今天是一个基础的题，感觉就是对编程技能的考察以及一部分数学知识。[5.等腰三角形 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/171/learning/?page=2&first_category_id=1&tags=枚举,模拟,前缀和,差分,二分,进制转换,贪心,位运算,双指针&tag_relation=union)

+ 注意把握坐标防止越界。

下午又做了一个题[7.日志统计 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/179/learning/?page=2&first_category_id=1&tags=枚举,模拟,前缀和,差分,二分,进制转换,贪心,位运算,双指针&tag_relation=union)

这个题还不错，学到了新东西，一个是unordered_map<int,vector<int>>,一个是复习了双指针算法中的滑动窗口。感觉自己算法基础不是很牢固啊，一个双指针AI写的那么简单我却写的很复杂，只能说还要练啊！

## 2024年10.12

今天是一个链表，不过我只是按照我的很复杂的形式写的，明天再研究简单的https://leetcode.cn/problems/add-two-numbers/description/

我是把链表存到了栈里边，然后进行操作导入向量res,明天在研究正常操作，水一天。

## 2024年10.13

早上7.53，直接完成了昨天晚上的链表，感觉很简单啊，没难度，超过了57的人，还行吧。

做题思路：从尾部开始遍历两个链表，并求和，然后加上一个jinzhi(初始是0)，令jinzhi = 他们的和/10，这样就能计算进位。然后向l3中填充tot%10,这样就能保证每个位置在0到10之间。然后如果这两个链表有一个或者两个遍历到最后了，先说两个的情况，如果此时jinzhi==1，那就在l3后填入1.一个的情况是类似于两个链表都不是空的操作，最后判断jinzhi，如果==1，在最后插入1

现在是晚上，本想做一道困难题，结果测试案例只通过了40，问gpt要代码还不如我自己写的。就写了一个相对简单的题，不过这个题我也学到了新东西，算是进步一点点吧，还复习了优先队列（默认为top最大元素）。学了个函数叫做round，这个函数是将一个浮点数以四舍五入的形式变为整数，那么结合这个函数就可以将浮点数四舍五入保留任意小数位。

```cpp
double res(double num,int k)//保留k位要看到第k+1位
{
    num = num * pow(10.0,k);
    return round(num)/pow(10.0,k);
    //有时候想不到可以举个例子，比如1.23保留1位小数
}
```

## 2024年10.15

时间过得真快啊，昨天没写算法题，都怪创新创业课，害我不小心看了一个小说，结果一下看完了，逆天！现在是早上9.01，第二节课是物理，直接敲，我相信不点名。

现在我决定主攻搜索和动态规划，图论的话放到最后吧。

我感觉搜索就是暴力枚举每一种情况，然后判断是否符合条件。

[P1036 [NOIP2002 普及组\] 选数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1036)

一道简单的枚举搜索。这种东西很难写笔记啊，走一步看一步吧！

首先从N个数中选出k个判断是否是素数，这明显是搜索每一种情况，然后判断是否是素数。

```cpp
void dfs(int tot,int times,int pos)
{
    if(times == k){
        if(is_prime(tot)) res++;
        return ;
    }
    for(int i = pos;i < n;i++)
    {
        dfs(tot+arr[i],times+1,i+1);//这里注意不要写成pos+1的情况，递归就是递进还有回归，写为Pos+1只能递进，回归的时候会出问题，假如说n==4k==3,当我第一次回归的时候，前两个是0，1，2的情况算过了，应该算3了，但是如果你使用的是位置+1，那么算的还是2，因为在回归的过程中，i变了，pos却不变，所以说不行。仔细想想还是可以想明白的。
    }
}
```

还有判断素数，想要快一点就用下面这个

```cpp
bool is_prime(int num)
{
    if(num<2) return false;
    if(num==2) return true;
    if(num%2==0) return false;
    for(int i = 3;i <= sqrt(num);i+=2)
    {
        if(num%i==0) return false;
	}
    return true;
}
```

优点：判断速度快，缺点：代码长。原理是利用偶数都不是素数，然后只判断奇数，在for循环中，i+=2是因为，奇数不可能整数偶数。

想要代码量少点就用这个：

```cpp
bool is_prime(int num)
{
    if(n<2) return false;
    for(int i = 2;i <= sqrt(num);i++)
    {
        if(num%i==0) return false;
    }
    return true;
}
```

[P1443 马的遍历 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1443)

这个题挺不错的，bfs可以直接写在main函数中，不用单独开一个函数。另外，我们使用bfs的时候总是会遇到某个点不知道该赋值为什么，这个题就解决了。

## 2024年10.16

今天是一个很值得怀念的题目https://www.luogu.com.cn/problem/P1219

N queens

还记得当时看了3天才看懂这个题目，如今的我已有单独做出来的能力，不过出现了一点小差错。

就是我在设置递归退出的条件时，从第0层开始搜索，应该是当层数==n时，要比搜的次数高一级，而不是恰好卡在n层，因为如果第n-1次的话还在搜最后一层，只有n次才是搜索完毕，开始填充答案，其他都好说。

## 2024年10.17

双指针[11. 盛最多水的容器 - 力扣（LeetCode）](https://leetcode.cn/problems/container-with-most-water/description/)

比接雨水简单！！！

这个题目简单的地方在于很容易计算两个柱子之间的降水量（不受中间柱子的影响），接雨水那个小丑题目麻烦死了。这个降水量就是看最两边的最小值。我刚开始是暴力枚举每一种情况，双层循环，但是超时了。然后我突然想到可以使用一种类似于动态规划的思想，不用开额外的数组。我们先把第一重循环当作左边的容器壁，然后倒着遍历数组，当作右边的容器壁，如果右边高度的大于等于左边的，就不用继续向左遍历了，一定比左边的大。但是如果右边的高度小于左边的高度，那就还要继续向左遍历，知道找到一个比右边的大的或者全部遍历完毕。使用一个res储存和维护最大值。不是很难。



## 2024年10.18

[55. 跳跃游戏 - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game/description/)

超越了100%的人是什么实力？我都不知道为什么这么快？？？

仔细想，如果数组中的每个数都大于0，那么肯定可以到达，如果数组第一位是0，那肯定到不了（除非数组长度是1），所以说我们只需要关注0所在的位置，而且要从后向前找，找到0就从这个位置向前遍历，如果nums[j]>i-j，证明可以跳过去，我们直接进入下一次循环，如果小于等于，那肯定跳不过去，就继续向前遍历，直到可以过去为止，如果遍历完了都过不去，直接返回false.最后在最后面返回true。

## 2024年10.20

[15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/description/)

很有意思的一道啊！我开始直接就想到了dfs爆搜，不出意外超时了，发现使用三个for循环也是爆搜。。。今天没写完，想了好长时间了，躺在床上想吧。不过学到了排序去重（这两个要结合在一起）

```cpp
vector<int> nums;
sort(nums.begin(),nums.end());
nums.erase(unique(nms.begin(),nums.end()),nums.end());
```

我的dfs这么帅，哎，看来还是要学记忆化搜索和动态规划啊，动态规划能不能解决这个问题呢？

## 2024年10.21

时间好快啊！！！今日温馨算法题：[20. 有效的括号 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-parentheses/submissions/574524498/)

这个是个简单题，但是如果没学过数据结构可能有点麻烦！我是在听栈的时候老师讲了这个题。将左括号入栈，右括号就看是否和栈顶元素匹配，匹配失败返回false。成功就继续这个操作。如果在匹配的过程中栈空了或者最后栈不空，返回false.

还是一个简单题[14. 最长公共前缀 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-common-prefix/)

哎，我真是堕落了，以前我都写中等的。

这个题使用二分法比较好，但是要了解字符串的substr方法。很简单的题，二分法仔细想想也不难理解的。

## 2024年10.22

[13. 罗马数字转整数 - 力扣（LeetCode）](https://leetcode.cn/problems/roman-to-integer/)

感觉这种题就是考验逻辑的，要有耐心，仔细观察吧，不涉及任何算法，单纯的if else.

很明显可以想到1和5是有关系的，10和50有关系，500和1000有关系。但是1和10也是有关系的，就是跳了一个5，这个是为了描述9。这个一旦想出来这个题目就解决了。

[12. 整数转罗马数字 - 力扣（LeetCode）](https://leetcode.cn/problems/integer-to-roman/)

这个和上面一样的，都是考逻辑的，if else 通过。

[17. 电话号码的字母组合 - 力扣（LeetCode）](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/)

不是，我说白了，这题有啥实力啊？直接爆搜狠狠拿下，没啥难的。

## 2024年10.23

[3185. 构成整天的下标对数目 II - 力扣（LeetCode）](https://leetcode.cn/problems/count-pairs-that-form-a-complete-day-ii/description/)

中等难度，这个和两数之和很相似，但是这个要考虑0和12这两个特殊情况，因为24-0是24，而hash表储存的数最大是23，还有24-12=12，而自己和自己不会构成一对，所以说要考虑这两个特殊情况。

[19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

题意如题名，既然是链表，就要考虑删除的是否是头节点或者是尾结点，这两个要if单独考虑，其他不足为虑。

## 2024年10.24

[3175. 找到连续赢 K 场比赛的第一位玩家 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-first-player-to-win-k-games-in-a-row/description/)

这是leetcode的每日一题，我感觉挺有意思的。我使用的双指针i指向较大的元素,j指向需要比较的元素，有一个陷阱就是如果skill[i]<skill[j]的话，i就应该等于j,j = i+1,此时要判断j是否等于len。还有就是tot = 1而不是0，并且还要判断tot是否等于k这种情况（防止第一次比较出问题）。

[21. 合并两个有序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-sorted-lists/description/)

[26. 删除有序数组中的重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

这两个都是简单题，基本不用思考。

## 2024年10.25

[52. N 皇后 II - 力扣（LeetCode）](https://leetcode.cn/problems/n-queens-ii/description/)

今天的每日一题是动态规划，卧槽，根本不会，从明天开始吧，专心练习动态规划。

找个比赛打打。

## 2024年10.26

卧槽，今天就搞了KMP算法，优化成我自己可以看懂的了，只不过next数组还没优化成功

## 2024年10.29

前两天都是做的leetcode简单题，没啥记录的价值，而且现在感觉学着有点吃力了，今天是看了一个题是给出一个n，如何求出满足长度是n的所有由0和1组成的字符串。这题放在以前我肯定不会，甚至没有任何思路，现在有思路了（递归）。是不是做一个题脑中一定要想到该怎么做，然后能否用现在的知识去实现，如果直到下一步是做什么，但是不知道如何实现，那就是水平问题，问一下chatgpt，看一下答案，学的多一点。

[3211. 生成不含相邻零的二进制字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/generate-binary-strings-without-adjacent-zeros/)

这个我的时间很长了，尽管剪枝了，但是效果不大，我直接就是暴力搜索所有情况，以前不知道怎么个搜法，现在知道了，用递归。

然后写一个check函数，在搜索中减去不可能的情况。

## 2024年10.30

[3216. 交换后字典序最小的字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/lexicographically-smallest-string-after-a-swap/submissions/576845591/)

leetcode每日一题，很简单。

## 2024年10.31

[983. 最低票价 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-cost-for-tickets/description/)

一个不是很好理解的动态规划。

## 2024年11.2

[3226. 使两个整数相等的位更改次数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-bit-changes-to-make-two-integers-equal/description/)

一个很简单的每日一题。

[516. 最长回文子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-subsequence/description/)

很好的动态规划，动态规划确实是我的弱点。

[72. 编辑距离 - 力扣（LeetCode）](https://leetcode.cn/problems/edit-distance/description/)

这个以前是个困难题，怎么变成中等了？

思路，对A删除一个字符相当于对B增加一个字符，对A或者B改变一个字符是一样的。创建以字符串长度为行列的二维数组，dp[i] [j]表示单词一0到i-1的字串变为单词二0到j-1的字串所需要的最小步数。首先我们要确定dp[i] [j]可以怎么过来。我们在前面分析的是对A或者B增加一个单词或者对A或者B改变一个单词，如果说是对一个增加，那么就是一个单词的前一个到另一个的当前的最小步数加1

如果是替换，那就可以来自0到i-1和0到j-1，如果最后加的字母相同就等于这个，否则就等于这个加1

## 2024年11.3

[15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/description/)

[18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/description/)

双指针

## 2024年11.4

[633. 平方数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-of-square-numbers/description/)

[167. 两数之和 II - 输入有序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/)

## 2024年11.5

[B-小歪商店故事：卷_牛客周赛 Round 67](https://ac.nowcoder.com/acm/contest/95016/B)

这个题确实很好啊，是我的知识盲区。如果让你求num<b*c/d的最大值你该如何求呢？

可能你会使用double来储存计算结果，但是要知道浮点数之间的运算是存在精度问题的，例如，即使计算结果接近整数，浮点运算也可能有极小的偏差，从而判断出错。

因此，我学到了 `(b * c - 1) / d` 始终会严格小于 `b * c / d`，但不会跨越一个整数区间。

就是如果后者是k.几，那么前者就不可能是k-1.几，数学证明不在赘述。

[C-小苯的计算式_牛客周赛 Round 67](https://ac.nowcoder.com/acm/contest/95016/C)

这么简单的题为啥比赛做不出来呢？！！

