# 算法

## sort()

一个升序或者降序的操作，它的第一个参数是开始排序元素的地址，第二个参数是结束排序元素的地址。注意都是包括在内，这是操作对象为数组的情况。如果是容器的话，那就填入迭代器。第三个参数如果不填的话那就默认升序，如果想要降序的话那就填入一个函数如下

```c++
bool compare(int a,int b)
{
    return a>b;
}
```

```c++
#include<algorithm>
#include<vector>
#include<iostream>
#include<stdbool.h>
using namespace std;
bool compare(int a, int b)
{
	return a > b;
}
void print_v(vector<int>& v)
{
	for (vector<int>::iterator it = v.begin();it != v.end();it++)
	{
		printf("%d\t", *it);
	}
}
int main()
{
	vector<int> v1;
	v1.push_back(42);
	v1.push_back(11);
	v1.push_back(36);
	v1.push_back(45);
	v1.push_back(32);
	sort(v1.begin(), v1.end(),compare);
	print_v(v1);
	return 0;
}
```

传入迭代器好吧，和指针一样。

2024年7月15日补充:

sort的第三个参数的工作原理，首先是返回值不一定是bool类型,但最好写为这个,如果return是true那么就让第一个元素排在第二个元素前面，否则就让第一个元素排在第二个元素后面.结束.

## 二分查找

```c++
//数组奇偶位数不影响查找
int binary_find(int arr[], int len, int ele)
{
	int left = 0;
	int right = len - 1;
	while (left <= right)
	{
		int mid = left + (right - left) / 2;
		if (arr[mid] == ele) return mid;
		if (arr[mid] > ele) {
			right = mid - 1;
		}
		else
		{
			left = mid + 1;
		}
	}
	return -1;
}
```

## 字符串转整数stoi

string to int(个人理解)

函数原型

```cpp
int stoi(const std::string& str, std::size_t* pos = 0, int base = 10);
```

### 参数说明

1. **str**: 要转换的字符串，类型为 `const std::string&`。
2. **pos**: 可选参数，类型为 `std::size_t*`，用于存储停止解析的位置的索引。如果没有指定，可以传递 `nullptr` 或者省略此参数。
3. **base**: 可选参数，类型为 `int`，表示数值的基数（如十进制、十六进制等）。默认值为10。

### 返回值

- 返回转换后的整数，类型为 `int`。

#### 使用 pos 参数

```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
    string str = "12345abc";
    size_t pos;
    int num = stoi(str, &pos);
    cout << "字符串转整数: " << num << endl; // 输出："字符串转整数: 12345"
    cout << "停止解析的位置: " << pos << endl; // 输出："停止解析的位置: 5"

    return 0;
}
```

#### 转换十六进制字符串

```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
    string str = "1A";
    int num = stoi(str, nullptr, 16);
    cout << "十六进制字符串转整数: " << num << endl; // 输出："十六进制字符串转整数: 26"

    return 0;
}
```

### 注意事项

1. **忽略前导空白**: `std::stoi` 函数会忽略字符串前面的空白字符（如空格、换行符等）。
2. **停止解析**: 一旦遇到非数字字符，将停止解析。
3. **异常处理**: 使用 `std::stoi` 时应当进行异常处理，特别是在处理用户输入时。
4. 可以直接解析负数。

### 总结

首先这个函数的返回值是10进制的（一定的）

其次，你要解析的字符串里面如果有字母，大小写是一样的

最后，`size_t pos`pos的值是根据你要转换的进制数确定的，加入你要将`"123asd"`转换为16进制，那么函数会转换所有，当遇到进制之外的字符时就会停止。比如你要转换二进制，那么第二个就会返回。

还有最重要的就是字符转数字，这个函数不能直接转char类型，所以必须将char转为string，直接上代码

```c++
char c = '5';
string char_to_string(1,c);//拷贝构造函数
int num = stoi(char_to_string);
```

## 整数转字符串to_string

```c++
std::string to_string( int value );
std::string to_string( long value );
std::string to_string( long long value );
std::string to_string( unsigned value );
std::string to_string( unsigned long value );
std::string to_string( unsigned long long value );
std::string to_string( float value );
std::string to_string( double value );
std::string to_string( long double value );
```

整数好说。浮点数？好吧，保存小数点后6位。想改变用printf.

## 进制转换函数（除k取余法）

```c++
string get_goal_base(int num,int base)
{
	string result;
	while(num>0)
	{
		int temp = num%base;
		num = num/base;
		if(temp<10)
		{
			result += (char)(temp+'0');
		}
		else
		{
			result += (char)('A'+temp-10);
		}
	}
	reverse(result.begin(),result.end());
	return result;
}
```

## 反转数字和字符reverse

这个函数很简单。

### 函数定义

以下是 `std::reverse` 的定义：

```cpp
template <class BidirectionalIterator>
void reverse(BidirectionalIterator first, BidirectionalIterator last);
```

### 参数说明

- `first`：表示需要反转区间的起始迭代器（包括此位置）。
- `last`：表示需要反转区间的结束迭代器（不包括此位置）。

### 特点

- **范围**：`std::reverse` 会反转从 `first` 到（`last-1`）位置的元素。
- **迭代器类型**：它要求传入的是双向迭代器（BidirectionalIterator），即支持双向遍历的迭代器。

## 快速遍历for

当我们想要遍历一个容器或者数组时，可以使用for

```c++
for(auto temp : arr or STL)
```

如果想要修改其中的值需要在temp前加上&

```c++
vector<int> v;
	v.push_back(10);
	v.push_back(20);
	v.push_back(30);
	v.push_back(40);
	for(auto &temp : v)
	{
		temp += 10;
		cout<<temp;
	}
	int arr[] = {1,2,3,4,5};
	for(auto temp : arr)
	{
		cout<<temp<<"\t";
	}
```

## 元组tuple

tuple是一个固定大小的不同类型值的集合，是泛化的std::pair。我们也可以把他当做一个通用的结构体来用，不需要创建结构体又获取结构体的特征，在某些情况下可以取代结构体使程序更简洁，直观。std::tuple理论上可以有无数个任意类型的成员变量，而std::pair只能是2个成员，因此在需要保存3个及以上的数据时就需要使用tuple元组了。

赋值操作:

```cpp
vector<tuple<int,int ,double,string>> arr;
for(int i = 0;i < len;i++)
{
    arr[i] = make_tuple(.....);
}
```

获取元素:

```cpp
//可以使用get或者使用tie解包
int a,b;double c;string d;
tie(a,b,c,d) = arr[0];
//get
cout<<get<0>(arr);
```

## 快速读入

```cpp
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
```

使用即可加快读入速度

## _int 128

`_int128` 是一种在某些编译器（如 GCC 和 Clang）中提供的扩展数据类型，用于表示 128 位的整数。它可以存储非常大的整数，范围远超常规的 64 位整数

特性
大小：`_int128` 占用 16 字节（128 位）。
范围：
有符号：从 -2^127 到 2^127 - 1
无符号：从 0 到 2^128 - 1

`_int128` 类型在标准 C++ 中没有内置的输入和输出支持，因此不能直接使用 `cin` 或` cout` 进行读入或输出。你只能对其进行赋值和运算。

不过可以自定义读入或者输出函数

```cpp
void print_int128(__int128 num) {
    if (num == 0) {
        cout << "0";
        return;
    }
    __int128 n = num;
    string result;
    while (n > 0) {
        result.push_back('0' + (n % 10));
        n /= 10;
    }
    reverse(result.begin(), result.end());
    cout << result;
}
__int128 read_int128() {
    string s;
    cin >> s;	
    __int128 result = 0;
    for (char c : s) {
        result = result * 10 + (c - '0');
    }
    return result;
}
```

## isstringstream



## list和deque的区别

C++ 中的 `list` 和 `deque` 都是容器，它们在操作上有一些相似之处，但在底层实现和性能方面有显著的区别。以下是它们之间的一些主要区别：

### 1. 底层实现

- **`list`**：是一个双向链表，每个元素都是一个节点，包含指向前一个和后一个元素的指针。因此，`list` 支持快速的插入和删除操作，但随机访问元素的性能较差。
- **`deque`**：是一个双端队列，底层实现通常为一块块的连续内存块，因此它既支持快速的随机访问，也支持在两端的快速插入和删除。

### 2. 访问元素的性能

- **`list`**：由于是链表结构，随机访问元素的时间复杂度为 O(n)，需要遍历链表。
- **`deque`**：类似于 `vector`，可以在常数时间内进行随机访问，时间复杂度为 O(1)。

### 3. 插入和删除的性能

- **`list`**：在任何位置插入和删除元素的时间复杂度为 O(1)，因为只需要调整指针。
- **`deque`**：在两端插入和删除元素的时间复杂度为 O(1)。在中间位置插入和删除的时间复杂度为 O(n)，因为需要移动元素。

### 4. 内存分配

- **`list`**：每插入一个元素，就需要为这个元素分配一个节点（包含指针），因此内存开销较大，且分布在堆上，不是连续的内存。
- **`deque`**：内存分配更接近 `vector`，通常分配一系列的连续内存块，因此整体内存管理效率较高。

### 5. 迭代器稳定性

- **`list`**：对 `list` 的插入和删除操作不会使其他元素的迭代器失效（除非删除的是该元素）。
- **`deque`**：在 `deque` 两端插入和删除操作可能会导致迭代器失效，因为内存可能需要重新分配和移动。

### 6. 应用场景

- **`list`**：适用于需要频繁在中间插入和删除元素的场景，且不需要随机访问元素的情况下，例如实现链表结构、频繁插入删除操作的队列等。
- **`deque`**：适用于需要频繁在两端插入和删除元素，同时需要快速随机访问元素的场景，例如实现双端队列、需要双向队列操作的算法等。

### 总结

- 如果需要高效的随机访问，`deque` 是更好的选择。
- 如果主要是中间插入和删除操作，`list` 更适合。
- 如果需要在两端进行大量插入和删除操作，且同时需要一定的随机访问能力，`deque` 是更好的选择。

## 那些容器支持随机访问

在C++中，容器的随机访问支持情况如下：

支持随机访问的容器：

vector：动态数组，支持通过索引快速访问元素。
deque：双端队列，支持通过索引访问元素。
array：固定大小的数组，支持随机访问。

不支持随机访问的容器：

list：双向链表，只支持顺序访问。
forward_list：单向链表，只支持顺序访问。
set 和 multiset：基于红黑树的集合，不支持随机访问。
map 和 multimap：基于红黑树的关联容器，不支持随机访问。
总结来说，vector、deque和array支持随机访问，而list、forward_list、set、map等则不支持。

## 如何将一个数字反转（顺便去除前导0 ）

我首先想到的是reverse函数，然后写一个while循环去除所有的前导0。如：

```cpp
int x;
string s = to_string(x);
s.reverse(s.begin(),s.end());
//这里还有stoi的操作。
while(s[0]=='0')
{
    s.erase(s.begin());
}
//还有一个更好的方法
int res = 0;
while(x!=0)
{
    res = res*10+x%10;
    x = x/10;
}
//这个是我从别人那里学来的，嘿嘿。
```

## 迅速的求出一个容器的最大或者最小元素

这里要使用到的方法是min_element(beg(),end())和max_element();

`std::min_element()` 的返回值是一个**迭代器**，它指向范围 `[first, last)` 中最小元素的位置。

如果这个容器是空的话，就会返回last。当然，max_element()也是一样的。

```cPP
vector<int> v = {9,5,4,8,3,1,6,2,8,7,5,41,12,36,58,74,15,36};
int minn = *min_element(v.begin(),v.end());
cout<<minn<<endl;
//如果是空的怎么办，第一种情况是使用empty方法提前判断，第二种就是
auto maxn = max_element(v.begin(),v.end());
if(maxn!=v.end())
{
	cout<<*maxn;
}
```

## 字符串求字串substr函数

这个方法还是比较好记的，因为只有一个构造函数。

```cpp
std::string substr(size_t pos = 0, size_t len = npos) const;
```

这里可以看出他的第一个参数默认是0，表示提取的位置，第二个参数默认值npos表示直到字符串的结尾。

因此他有下面两种用法：

```cpp
string s;
sub = s.substr(0,5);//从0开始提取5个
sub = s.substr(1);//提取从1直到结尾
```

字符串的insert方法和append方法

```cpp
std::string& insert(size_t pos, const std::string& str);
std::string& insert(size_t pos, const char* s);
std::string& insert(size_t pos, const char* s, size_t n);
std::string& insert(size_t pos, size_t n, char c);



std::string& append(const std::string& str);
std::string& append(const char* s);
std::string& append(const char* s, size_t n);
std::string& append(size_t n, char c);
```

## 将小数四舍五入保留

我们在有时候会用到四舍五入保留特定位数浮点数的情况，这有一种输出方式可以让我们输出想要的答案

```cpp
cout<<fixed<<setprecision(n)<<double 类型的变量<<endl;
```

`fixed` 和 `setprecision(2)` 是用于格式化输出的操作符。

- `fixed`：这个操作符用于设置浮点数的输出格式为定点格式。也就是说，输出的数字将以小数形式显示，而不是科学计数法。
- `setprecision(2)`：这个函数用于设置输出的数字的小数位数。在这里，`setprecision(2)` 表示输出的小数部分四舍五入保留两位

## Lambda表达式的用法

```ABAP
[捕获列表](参数列表) -> 返回类型 { 函数体 };
```

**说明**

- **`[]` 捕获列表（Capture List）**：定义 lambda 如何捕获外部变量（传值、传引用等）。
- **`() `参数列表（Parameter List）**：可选，类似普通函数的参数。
- **`-> 返回类型`（Return Type）**：可选，C++14 及以上可自动推导。
- **`{}` 函数体（Function Body）**：函数的具体实现。

### **2. 最简单的 Lambda**

```cpp
#include <iostream>
using namespace std;

int main() {
    auto func = []() { cout << "Hello Lambda!" << endl; };
    func();  // 调用 lambda
}
```

**解释**：

- `[]` 表示 **lambda 没有捕获任何外部变量**。
- `()` 为空，说明**无参数**。
- `{}` 里是 **lambda 的函数体**，直接 `cout`。

------

### **3. 带参数的 Lambda**

```cpp
auto add = [](int a, int b) { return a + b; };
cout << add(3, 4) << endl;  // 输出: 7
```

这里 `[](int a, int b) { return a + b; }` 是一个匿名函数，它接受两个 `int` 并返回它们的和。

------

### **4. 显式返回类型**

有时候返回类型难以推导，可以 **手动指定返回类型**：

```cpp
auto divide = [](double a, double b) -> double {
    if (b == 0) return 0;
    return a / b;
};
cout << divide(10, 2) << endl;  // 输出: 5
```

`-> double` 指定返回 `double`，如果 `b == 0`，则返回 `0`（默认 `int`）。

------

### **5. 捕获外部变量**

Lambda 可以**访问外部作用域的变量**，但需要在 `[]` 里**指定捕获方式**。

### **(1) 值捕获 `[=]`**

```cpp
int x = 10;
auto printX = [=]() { cout << x << endl; };  // 捕获 x 的值
x = 20;
printX();  // 输出 10（因为 x 是按值捕获的，捕获时 x 的值是 10）
```

> `= `让 lambda **复制外部变量**，**即使外部变量后续修改，lambda 内部值不变**。

------

### **(2) 引用捕获 `[&]`**

```cpp
int x = 10;
auto printX = [&]() { cout << x << endl; };  // 捕获 x 的引用
x = 20;
printX();  // 输出 20（因为 x 是引用捕获的）
```

> `& `让 lambda **直接访问原变量**，如果原变量变了，lambda 内部的值也会变。

------

### **(3) 指定变量捕获**

```cpp
int x = 10, y = 20;

auto lambda1 = [x]() { cout << x << endl; }; // 仅捕获 x 的值
auto lambda2 = [&y]() { cout << y << endl; }; // 仅捕获 y 的引用

x = 30, y = 40;
lambda1();  // 输出 10（x 按值捕获）
lambda2();  // 输出 40（y 按引用捕获）
```

------

### **6. Lambda 作为参数**

```cpp
void operate(int a, int b, auto func) {
    cout << func(a, b) << endl;
}

int main() {
    operate(5, 3, [](int x, int y) { return x + y; });  // 输出 8
    operate(5, 3, [](int x, int y) { return x * y; });  // 输出 15
}
```

**解释**：

- `operate` 接受一个 `lambda` 作为参数，执行不同运算。
- `[](int x, int y) { return x + y; }` 传入 `operate` 计算和。

## isalnum()和tolower()函数

`isalnum()` 是 C++ 标准库中的一个函数，用于检查一个字符是否是字母（`a-z`, `A-Z`）或数字（`0-9`）。如果是字母或数字，返回 `true`，否则返回 `false`。

`tolower()` 是 C++ 标准库中的一个函数，用于将大写字母转换为小写字母。如果`字符`不是大写字母，则保持不变。

## lower_bound()函数

`lower_bound()` 是 C++ 标准库中的一个函数，用于在**已排序的范围**内查找第一个**不小于**给定值的元素。它通常用于在有序容器（如 `vector`、`array`、`set` 等）中执行二分查找。

它有四个参数，前两个不用多说，代表要查找的范围。第三个参数是一个值x,查找的就是第一个>=x的元素，注意返回的是元素迭代器。

注意的是：使用它必须要保证数组是单调不减的，这样就可以忽略第四个参数的影响力（即使用默认的就行）

它的本质是二分查找，所以时间复杂度是:
$$
\log_{2}(n)
$$
upper_bound()这个和上面的唯一区别就是找到严格大于X的数字。

注意如果不存在会返回end();

## c++高精度算法

没有高精度除法（）至少目前没看到，遇到了再说；

高精度算法分为整数和浮点数，但是其实就是使用字符串来模拟了这个过程，因此我们只需要了解整数运算，在考虑好小数点的位置就可以模拟出乘法运算。（不过我记得前面好像写过模拟加法运算，好像是去年（2024）写的），后面写啥的时候烂尾了。

### 整数加法

```cpp
vector<int> bignumadd(vector<int>& a,vector<int>& b)
{
	int lena = a.size(),lenb = b.size();
	int lenres = max(lena,lenb)+1;
	vector<int> res(lenres,0);
	int i = lena-1,j = lenb-1,k = lenres-1;
	res[k] = a[i]+b[j];
	i--,j--,k--;
	while(i>=0&&j>=0)
	{
		res[k] = a[i]+b[j]+res[k+1]/10;
		res[k+1] %= 10;
		i--,j--,k--;
	}
	while(i>=0)
	{
		res[k] = a[i]+res[k+1]/10;
		res[k+1] %= 10;
		i--,k--;
	}
	while(j>=0)
	{
		res[k] = b[j]+res[k+1]/10;
		res[k+1] %= 10;
		j--,k--;
	}
	if(!res[0]) res.erase(res.begin();
	return res;
}
int main()
{
	string s1,s2;
	cin>>s1>>s2;
	vector<int> a,b;
	for(int i = 0;i < s1.length();i++) a.push_back(s1[i]-'0');
	for(int i = 0;i < s2.length();i++) b.push_back(s2[i]-'0');
	vector<int> res = bignumadd(a,b);
	for(const auto &i:res) cout<<i;
	return 0;
}
```











## 控制输出位置，位数，补全字符

```cpp
setfill(char c)
//第一个函数，填充字符setfill(' ')//默认是空格
//1。setfill函数只能和cout<<一起使用，单独使用不行
//2.setfill只要改变一次，之后的输出都会使用改变过的填充

setw(int width)//setwidth
//这个函数用来改变你要输出的数字的占位
    
right,left//就是左对齐和右对齐

    
    
输出一个长度为5，右对齐，填充为'*'的数字
cout<<setw(5)<<right<<setfill('*')<<num;
如果这个数字的长度大于了5，那么不会对数字截断，会输出原数字。
```

## GCD和LCM

最大公约数gcd函数可以有欧几里得算法（辗转相除法）得到

这是迭代写法,更加省时

```cpp
int gcd(int a,int b)
{
    while(b!=0)
    {
        int temp = b;
        b = a%b;
        a = temp;
    }
    return a;
}//当a<b时，第一次循环会交换两个数的位置

int gcd(int a,int b)
{
    return b==0?a:gcd(b,a%b);
}
```

LCM要靠GCD来实现


$$
\text{lcm}(a, b) = \frac{|a \times b|}{\gcd(a, b)}
$$
为了防止a*b太大引发溢出，所以：

```cpp
int lcm(int a,int b)
{
    return (a/gcd(a,b))*b;
}
```

## 如何求一个数组中最大的连续子序列？

前奏：

先看一个模型，我称之为：股票模型。

如果说你知道n天的股票价格，那么如何购买才能获得最大利润？

很明显，我们要在尽量低的位置购入，高的位置卖出，但是卖出的时间又必须在购入的时间后面。将模型抽象：

给定一个数组nums,找到最大的nums[j]-nums[i],j>=i.

第一个方法：开辟两个数组，分别记录从左到右的最小值和从右到左的最大值，然后再扫一遍，求出最大差。

第二个方法：使用一个变量cur_min记录最小值，然后再遍历的过程中不断更新最小值，与此同时，把当前的nums[i]当作要卖出的日子，计算能够获得的利润，最后取最大值即可。

我们重新回顾模型，可以注意到j>=i。也就是说最差最差我们可以不赔钱。

```cpp
int cur_min = nums[0];
int res = INT_MIN;
for(int i = 0;i < len;i++)
{
    cur_min = min(cur_min,nums[i]);
    res = max(res,nums[i]-cur_min);
    //循环里面是先更新最小值，然后求利润。能否先求利润，再更新最小值呢？如果说是从0开始，那无所谓，如果从1开始必须要先更新最小值。
    //所以说如果是j>=i的情况，不论从几开始，直接先更新，再求值。
    [2,1,0]
}
```

模型变化：

如果说今天买的股票我今天不能卖，只能到明天才可以卖，代码又该如何写？

那就是j>i的情况了。那我们最快能卖的就是第二天了。

```cpp
int cur_min = nums[0];
int res = INT_MIN;//nums[1]-nums[0]
for(int i = 1;i < len;i++)
{
    res = max(res,nums[i]-cur_min);
    cur_min = min(cur_min,nums[i]);
    //不能先更新最小值，因为当天不能买。
}
```

总结一下：只要明确循环的意义就可以很容易理解。循环到i表示我要试图在第i天卖出，如果是j>=i,就证明当天即可以买又可以卖，因此我们可以先更新最大值。如果是j>i,就证明我要在今天卖，但是今天不能同时买和卖，所以说要拿前几天的最小值来说话。

正文：

看到子数组连续和很容易想到前缀和，我们将nums数组前缀自己后，如果我们要找的子数组不能为空，也就是至少要有一个元素，那我们就可以将其抽象为变式股票模型（j>i）。但是我们要再nums数组前插入一个0，这样才算是考虑到了每种情况，使用insert(nums.begin(),0);

如果是子数组可以为空，我们可以抽象为普通的股票模型。

当然，以上不是最简单的方法，最简单的方法是dp

```cpp
dp[0] = nums[0];
for(int i = 1;i < len;i++)
{
    if(dp[i-1]<0) dp[i] = nums[i];
    else dp[i] = dp[i-1]+nums[i];
}
return *max_element(dp.begin(),dp.end());
```

dp[i]表示以第i个元素结尾最大数是多少。



## 素数判断

对于单个的数字

```cpp
if(num<2) return false;
for(int i = 2;i*i<=num;i++){
    if(num%i==0) return false;
}
return true;
```

埃拉托斯特尼筛法（用于判断很多数是否是质数）

```cpp
const int MX = 1'000'001;  // 预处理范围 [0, MX)
bool is_prime[MX];         // is_prime[i] 表示 i 是否为质数
vector<int> primes;        // 存储所有质数

// 利用 lambda 立即执行初始化
auto init = [] {
    ranges::fill(is_prime, true);  // 初始假设所有数都是质数
    is_prime[0] = is_prime[1] = false; // 0 和 1 不是质数

    for (int i = 2; i < MX; i++) {
        if (is_prime[i]) {        // 如果 i 是质数
            primes.push_back(i);   // 将 i 加入质数列表
            // 标记 i 的所有倍数为非质数（从 i*i 开始，因为更小的倍数已被处理）
            for (long long j = 1LL * i * i; j < MX; j += i) {
                is_prime[j] = false;
            }
        }
    }
    return 0; // 返回任意值，仅用于立即执行 lambda
}();
```

