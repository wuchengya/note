# 数据结构与算法

## 线性表

### 顺序存储实现：

```c++
#include <iostream>
using namespace std;

const int MAX_SIZE = 100; // 线性表的最大容量

struct SeqList {
	int data[MAX_SIZE]; // 用数组存储数据元素
	int length; // 当前线性表的长度
};

// 初始化线性表
void InitList(SeqList &L) {
	L.length = 0;
}

// 在指定位置插入元素
bool Insert(SeqList &L, int pos, int value) {
	if (pos < 1 || pos > L.length + 1 || L.length == MAX_SIZE) {
		return false; // 插入位置不合法或线性表已满
	}
	
	for (int i = L.length - 1; i >= pos - 1; i--) {
		L.data[i + 1] = L.data[i]; // 后移元素腾出位置
	}
	L.data[pos - 1] = value; // 插入新元素
	L.length++; // 长度加一
	return true;
}

// 删除指定位置的元素
bool Delete(SeqList &L, int pos) {
	if (pos < 1 || pos > L.length) {
		return false; // 删除位置不合法
	}
	
	for (int i = pos; i < L.length; i++) {
		L.data[i - 1] = L.data[i]; // 前移元素覆盖被删除元素
	}
	L.length--; // 长度减一
	return true;
}

// 打印线性表元素
void PrintList(SeqList &L) {
	for (int i = 0; i < L.length; i++) {
		cout << L.data[i] << " ";
	}
	cout << endl;
}
```



### 链表实现：

#### 单链表

```c++
#include<iostream>
using namespace std;
class node
{
public:
	int data;
	node* next;
	node(int data)
	{
		this->next = nullptr;
		this->data = data;
	}
};
class Linklist
{
private:
	node* head;
public:
	Linklist();
	void append(int data)
	{
		node* new_data = new node(data);
		if(head == nullptr)
		{
			head = new_data;
			return;
		}
		node* current_node = head;
		while(current_node->next != nullptr)
		{
			current_node = current_node->next;
		}
		current_node->next = new_data;
	}
	void Print_list()
	{
		if(head == nullptr)
		{
			cout<<"链表数据为空"<<endl;
			return;
		}
		node* current_node = head;
		while(current_node != 0)
		{
			cout<<current_node->data<<" -> ";
			current_node = current_node->next;
		}
		cout<<"nullptr";
	}
	void insert(int insert_data,int insert_place)
	{
		node* new_node = new node(insert_data);
		if(head == nullptr)
		{
			cout<<"链表为空，插入元素将排在第一位"<<endl;
			head = new_node;
			return;
		}
		if(insert_place == 1)
		{
			new_node->next = head;
			head = new_node;
			return;
		}
		node* current_node = head;
		int num = 1;
		while(current_node != nullptr && num < insert_place)
		{
			if(num == insert_place-1)
			{
				new_node->next = current_node->next;
				current_node->next = new_node;
				break;
			}
			current_node = current_node->next;
			num++;
		}
	}
	void Delete(int delete_place)
	{
		if(head == nullptr)
		{
			cout<<"链表为空，操作失败"<<endl;
			return;
		}
		if(delete_place == 1)
		{
			node* temp = head;
			head = head->next;
			delete temp;
			return;
		}
		int num = 1;
		node* current_node = head;
		while(current_node != nullptr && num < delete_place - 1)
		{
			current_node = current_node->next;
			num++;
		}
		if(current_node == nullptr || current_node->next == nullptr)
		{
			cout<<"删除范围大于链表长度"<<endl;
			return;
		}
		if(current_node->next->next == nullptr)
		{
			cout<<"此元素是链表最后一位，确定要删除吗？:";
			string result;
			cin>>result;
			if(result == "是")
			{
				node* temp = current_node->next;
				current_node->next = nullptr;
				delete temp;
				return;
			}
			else
			{
				cout<<"已退出"<<endl;
				return;
			}
		}
		node* temp = current_node->next;
		current_node->next = current_node->next->next;
		delete temp;
	}
	void Delete_all_linklist()
	{
		if(head == nullptr)
		{
			cout<<"Linklist has been empty"<<endl;
			return;
		}
		node* current_node = head->next;
		head = nullptr;
		while(current_node != nullptr)
		{
			node* temp = current_node;
			current_node = current_node->next;
			delete temp;
		}
		cout<<"The operation is complete"<<endl;
	}
};
Linklist::Linklist()
{
	head = nullptr;
}
int main()
{
	Linklist list;
	list.append(1);
	list.append(2);
	list.append(3);
	list.insert(4,4);
	list.Delete_all_linklist();
	list.Print_list();
	return 0;
}
```

#### 静态链表

静态链表是不使用指针而制作出来的链表，使用场合少。用到时自己查

#### 循环链表

```c++
#include <iostream>
using namespace std;
class node
{
public:
	int data;
	node* next;
	node(int data)
	{
		this->next = nullptr;
		this->data = data;
	}
};
class Linklist
{
private:
	node* head;
public:
	Linklist()
	{
		head = nullptr;
	}
	void append(int data)
	{
		node* new_node = new node(data);
		if(head == nullptr)
		{
			head = new_node;
			head->next = head;
			return ;
		}
		node* current_node = head;
		while(current_node->next != head)
		{
			current_node = current_node->next;
		}
		current_node->next = new_node;
		new_node->next = head;
	}
	void Print_list()
	{
		if(head == nullptr)
		{
			cout<<"linklist elements nullptr"<<endl;
			return;
		}
		node* current_node = head->next;
		cout<<head->data<<" -> ";
		while(current_node != head)
		{
			cout<<current_node->data<<" -> ";
			current_node = current_node->next;
		}
		cout<<"headptr";
	}
	int get_list_length()
	{
		if(head == nullptr)
		{
			return 0;
		}
		int length = 1;
		node* current_node = head;
		while(current_node->next != head)
		{
			length++;
			current_node = current_node->next;
		}
		return length;
	}
	void Insert(int insert_data,int insert_place)
	{
		node* new_node = new node(insert_data);
		node* current_node = head;
		if(insert_place == this->get_list_length()+1)
		{
			this->append(insert_data);
			return;
		}
		if(insert_place > this->get_list_length()+1)
		{
			cout<<"The insertion position exceeds the length of the linked list"<<endl;
			return;
		}
		if(head == nullptr)
		{
			cout<<"The linked list is empty, and the inserted element will be put first"<<endl;
			head = new_node;
			head->next = head;
			return ;
		}
		if(insert_place == 1)
		{
			while(current_node->next != head)
			{
				current_node = current_node->next;
			}
			new_node->next = head;
			current_node->next = new_node;
			head = new_node;
			return;
		}
		insert_place -= 2;
		while(insert_place != 0)
		{
			insert_place--;
			current_node = current_node->next;
		}
		new_node->next = current_node->next;
		current_node->next = new_node;
	}
	void Delete(int delete_place)
	{
		node* current_node = head;
		if(this->get_list_length() == 0)
		{
			cout<<"The linked list is empty, and the operation failed"<<endl;
			return;
		}
		if(delete_place == 1)
		{
			if(this->get_list_length() == 1)
			{
				delete head;
				head = nullptr;
			}
			else
			{
				while(current_node->next != head)
				{
					current_node = current_node->next;
				}
				node* temp = current_node->next;
				current_node->next = head->next;
				head = head->next;
				delete temp;
				return;
			}
		}
		
		if(delete_place > this->get_list_length())
		{
			cout<<"The deletion position is greater than the length of the linked list"<<endl;
			return;
		}
		if(delete_place == this->get_list_length())
		{
			while(current_node->next->next != head)
			{
				current_node = current_node->next;
			}
			node* temp = current_node->next;
			current_node->next = head;
			delete temp;
			return;
		}
		for(int i = delete_place - 2;i != 0;i--)
		{
			current_node = current_node->next;	
		}
		node* temp = current_node->next;
		current_node->next = temp->next;
		delete temp;
		
	}
};
```


循环链表与普通链表相比有几个优势：

1. **循环性质：** 循环链表是一种特殊的链表，其最后一个节点指向第一个节点，形成一个闭环。这使得在循环链表上进行循环遍历更为方便，因为不需要额外的条件来判断链表是否结束，只需要判断当前节点是否等于起始节点即可。
2. **操作效率：** 对于某些场景，循环链表在插入和删除操作上可能更高效。在循环链表中，删除和插入一个节点不需要维护前一个节点的指针，因此在某些情况下可以减少指针的修改次数，提高操作效率。
3. **空间利用：** 循环链表在某些情况下可以节省空间。在普通链表中，为了方便处理边界条件，通常需要一个指针指向链表的头部。而在循环链表中，由于头部和尾部相连，因此不需要额外的头指针，节省了一个指针的空间。
4. **实际应用：** 循环链表在某些实际应用中具有特殊的优势，例如循环缓冲区。在循环缓冲区中，数据的读取和写入是连续的，循环链表的结构可以很好地模拟这种环形的数据结构。

总的来说，循环链表相比于普通链表在某些场景下能够提供更好的效率和方便性，但并不适用于所有情况。在选择数据结构时，需要根据具体的需求和场景来决定是否使用循环链表

#### 双向链表

```c++
#include<iostream>
using namespace std;
class node
{
public:
	int data;
	node* prev;
	node* next;
	node(int data)
	{
		this->data = data;
		this->prev = nullptr;
		this->next = nullptr;
	}
};
class Linklist
{
private:
	node* head;
	node* tail;
public:
	Linklist()
	{
		head = nullptr;
		tail = nullptr;
	}
	int get_length();
	void add_from_front(int data)
	{
		node* new_data = new node(data);
		if(this->get_length() == 0)
		{
			head = new_data;
			tail = new_data;
			return;
		}
		new_data->next = head;
		head->prev = new_data;
		head = new_data;
	}
	void add_from_behind(int data)
	{
		node* new_data = new node(data);
		if(this->get_length() == 0)
		{
			head = new_data;
			tail = new_data;
			return;
		}
		tail->next = new_data;
		new_data->prev = tail;
		tail = new_data;
	}
	void printlist();
	void Delete(int delete_position)
	{
		//链表为空
		if(this->get_length() == 0)
		{
			cout<<"The linked list element is empty"<<endl;
		}
		//删除位置是1
		else if(delete_position == 1)
		{
			if(this->get_length() == 1)
			{
				head = nullptr;
				tail = nullptr;
			}
			else
			{
				node* temp_node = head;
				head = nullptr;
				head = temp_node->next;
				delete temp_node;
			}
		}
		//删除位置错误
		else if(delete_position > this->get_length())
		{
			cout<<"The deletion position is greater than the length of the linked list"<<endl;
		}
		else if(delete_position <= 0)
		{
			cout<<"Operational errors"<<endl;
		}
		//删除最后一个元素
		else if(delete_position == this->get_length())
		{
			node* temp_node = tail;
			tail = tail->prev;
			delete temp_node;
		}
		else
		{
			node* current_node = head;
			for (int i = 1; i < delete_position; i++)
			{
				current_node = current_node->next;
			}
			current_node->prev->next = current_node->next;
			current_node->next->prev = current_node->prev;
			delete current_node;
		}
	}
	void Insert(int insert_data,int insert_position);
};
void Linklist::Insert(int insert_data,int insert_position)
{
	if(this->get_length() == 0)
	{
		cout<<"The linked list element is empty"<<endl;
		return;
	}
	if(insert_position > this->get_length()+1 || insert_position <=0)
	{
		cout<<"Operational errors"<<endl;
		return;
	}
	if(insert_position == 1)
	{
		this->add_from_front(insert_data);
		return;
	}
	if(insert_position == this->get_length()+1)
	{
		this->add_from_behind(insert_data);
		return;
	}
	node* new_node = new node(insert_data);
	node* current_node = head;
	for(int i = 1;i < insert_position - 1;i++)
	{
		current_node = current_node->next;
	}
	new_node->next = current_node->next;
	current_node->prev = new_node;
	current_node->next = new_node;
	new_node->prev = current_node;
}
int Linklist::get_length()
{
	int len = 1;
	if(head == nullptr)
	{
		len = 0;
		return len;
	}
	node* current_node = head;
	while(current_node != tail)
	{
		current_node = current_node->next;
		len++;
	}
	return len;
}
void Linklist::printlist()
{
	if(this->get_length() == 0)
	{
		cout<<"The linked list element is empty"<<endl;
		return;
	}
	node* current_node = head;
	while(current_node != tail)
	{
		cout<<current_node->data<<" -> ";
		current_node = current_node->next;
	}
	cout<<current_node->data<<" -> ";
	cout<<"nullptr";
}
int main()
{
	Linklist list;
	list.add_from_behind(1);
	list.add_from_behind(2);
	list.add_from_behind(3);
	list.add_from_behind(4);
	list.add_from_behind(5);
	list.add_from_front(0);
	list.Delete(3);
	list.Insert(2,3);
	list.printlist();
	return 0;
}
```

线性表的顺序存储结构和链表都是常见的数据结构，它们各有优势和适用场景，因此在实际应用中都有广泛的使用。

顺序存储结构适用于以下场景：

1. 需要频繁按照下标随机访问元素的情况，因为顺序存储结构可以通过下标直接访问元素，时间复杂度为 O(1)。
2. 对于已知数据规模并且不经常进行插入和删除操作的情况，因为在顺序存储结构中插入和删除操作可能需要移动大量元素，时间复杂度为 O(n)。
3. 对于内存连续、固定大小的数据，如数组，适合使用顺序存储结构。

链表适用于以下场景：

1. 需要频繁进行插入和删除操作的情况，因为链表插入和删除操作只需要改变指针指向，时间复杂度为 O(1)。
2. 对于未知数据规模或需要动态扩展的情况，因为链表可以动态分配内存，不受固定大小的限制。
3. 需要频繁进行元素移动和重排的情况，因为链表的插入和删除操作不需要移动大量元素。

综上所述，顺序存储结构和链表各有自己的优势和适用场景，具体使用哪种数据结构取决于具体的需求和应用场景。在实际开发中，通常会根据具体情况选择合适的数据结构来实现功能。

## 栈

### 栈的顺序存储结构及实现：

使用数组实现栈是一种简单且高效的方法。数组的优势在于快速的随机访问，但缺点是大小固定。

```c++
#include<iostream>
using namespace std;
#define MAX_SIZE 100
class stack
{
private:
	int arr[MAX_SIZE];
	int top;
public:
	bool is_empty()
	{
		return (top == -1);
	}
	stack()
	{
		top = -1;
	}
	void push(int value)
	{
		if(top == MAX_SIZE - 1)
		{
			cout<<"stack overflow"<<endl;
			return ;
		}
		arr[++top] = value;
	}
	void pop()
	{
		if(is_empty())
		{
			cout<<"stack underflow"<<endl;
			return;
		}
		top--;
	}
	int peek()
	{
		if(is_empty())
		{
			cout<<"stack underflow"<<endl;
			return -1;
		}
		else
		{
			return arr[top];	
		}
		
	}
};
```

这里可能会对arr[++top]有些疑问：

经过arr[++top] = value;这行代码后，top的值会在原来的基础上加一吗？

ChatGPT:

是的，经过 `arr[++top] = value;` 这行代码后，`top` 的值会在原来的基础上加一。

在这行代码中，`++top` 表示先将 `top` 的值加一，然后再将新的值赋给 `arr` 数组。这意味着在将 `value` 存储到 `arr` 数组中的下一个位置之前，`top` 的值就会增加，指向新的栈顶元素的位置。

### 栈的链表实现：

链表实现栈相对来说更加灵活，因为它不受固定大小的限制，但是在某些操作上可能稍微慢一些。

```c++
class node
{
public:
	int data;
	node* next;
	node(int data)
	{
		this->data = data;
		next = nullptr;
	}
};
class stack
{
private:
	node* top;
public:
	stack()
	{
		top = nullptr;
	}
	bool is_empty()
	{
		return (top == nullptr);
	}
	//尝试了从后面连接元素，但是这种方式行不通，所以只能从前面连接元素。
	void push(int value)
	{
		node* new_node = new node(value);
		new_node->next = top;
		top = new_node;
	}
	void pop()
	{
		if(this->is_empty())
		{
			cout<<"stack underflow"<<endl;
			return;
		}
		node* temp = top;
		top = top->next;
		delete temp;
	}
	int peek()
	{
		if(this->is_empty())
		{
			cout<<"stack underflow"<<endl;
			return -1;
		}
		return top->data;
	}
};
```

## 队列

### 顺序存储实现：

对列虽然有顺序存储，但是有很大的弊端

因此只掌握链式存储即可。

以后用到顺序存储再说。

chtgpt:

```c++
#include <iostream>

using namespace std;

#define MAX_SIZE 100

class Queue {
private:
    int arr[MAX_SIZE]; // 用于存储队列元素的数组
    int front; // 队列头指针
    int rear;  // 队列尾指针

public:
    Queue() {
        front = rear = -1;
    }

    // 入队操作
    void enqueue(int value) {
        if (rear == MAX_SIZE - 1) {
            cout << "Queue is full. Cannot enqueue." << endl;
            return;
        }
        if (isEmpty()) {
            front = rear = 0;
        } else {
            rear++;
        }
        arr[rear] = value;
    }

    // 出队操作
    void dequeue() {
        if (isEmpty()) {
            cout << "Queue is empty. Cannot dequeue." << endl;
            return;
        }
        if (front == rear) {
            front = rear = -1;
        } else {
            front++;
        }
    }

    // 获取队头元素
    int getFront() {
        if (isEmpty()) {
            cout << "Queue is empty." << endl;
            return -1; // 返回一个特殊值表示队列为空
        }
        return arr[front];
    }

    // 检查队列是否为空
    bool isEmpty() {
        return (front == -1 && rear == -1);
    }
};

```

用数组实现的循环队列：

```c++
#include <iostream>

using namespace std;

#define MAX_SIZE 100

class Queue {
private:
    int arr[MAX_SIZE]; // 用于存储队列元素的数组
    int front; // 队列头指针
    int rear;  // 队列尾指针

public:
    Queue() {
        front = rear = 0; // 初始化 front 和 rear 指针为数组的开头
    }

    // 入队操作
    void enqueue(int value) {
        if ((rear + 1) % MAX_SIZE == front) {
            cout << "Queue is full. Cannot enqueue." << endl;
            return;
        }
        arr[rear] = value;
        rear = (rear + 1) % MAX_SIZE; // rear 指针循环到数组的开头
    }

    // 出队操作
    void dequeue() {
        if (isEmpty()) {
            cout << "Queue is empty. Cannot dequeue." << endl;
            return;
        }
        front = (front + 1) % MAX_SIZE; // front 指针循环到数组的开头
    }

    // 获取队头元素
    int getFront() {
        if (isEmpty()) {
            cout << "Queue is empty." << endl;
            return -1; // 返回一个特殊值表示队列为空
        }
        return arr[front];
    }

    // 检查队列是否为空
    bool isEmpty() {
        return (front == rear);
    }
};

```



### 队列的链式结构的实现：

```c++
#include<iostream>
using namespace std;

class Node {
public:
    int data;
    Node* next;

    Node(int data) {
        this->data = data;
        next = nullptr;
    }
};

class Queue {
private:
    Node* head;
    Node* tail;

public:
    Queue() {
        head = nullptr;
        tail = nullptr;
    }

    bool is_empty() {
        return (head == nullptr);
    }

    void enqueue(int data) {
        Node* new_node = new Node(data);
        if (is_empty()) {
            head = tail = new_node;
        } else {
            tail->next = new_node;
            tail = new_node;
        }
    }

    void dequeue() {
        if (is_empty()) {
            cout << "The queue is empty" << endl;
            return;
        }
        Node* temp = head;
        head = head->next;
        delete temp;
        if (head == nullptr) {
            tail = nullptr; // 更新 tail
        }
    }

    int front() {
        if (is_empty()) {
            cout << "The queue is empty" << endl;
            return -1;
        }
        return head->data;
    }

    void clear() {
        while (!is_empty()) {
            dequeue();
        }
    }

    ~Queue() {
        clear(); // 释放动态分配的内存
    }
};

```

对于循环队列与链队列的比较，可以从两方面来考虑，从时间上，其实它们的基 本操作都是常数时间，即都为 0(1) 的，

不过循环队列是事先申请好空间，使用期间不 释放，而对 链队列，每次申请和释放结点也会存在一些时间开销，如果入

队出队频 繁，则两者还是有细微差异。对于空间上来说，循环队列必须有一个固定的长度，所 以就有了存储元素个数和

军间浪费的问题。而链队列不存在这个问题，尽管官需要一 指针域， 会产生 些空间上的开销，但也可以接受 所以在空间

上，链队列更加灵 活。 总的来说，在可以确定队列长度最大值的情况 ，建议用循环队列，如果你无法预估队列的长时，

则用链队列。
